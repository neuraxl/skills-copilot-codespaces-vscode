<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NeuraX-Ultime | Le Cerveau Vivant</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

    body {
      margin: 0;
      background: radial-gradient(ellipse at center, #000014 0%, #000010 100%);
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
      color: #00ffcc;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }
    #interface {
      position: relative;
      z-index: 1;
      text-align: center;
      margin-top: 10vh;
      padding: 0 2em;
      transition: opacity 1s ease;
    }
    h1 {
      font-size: 3em;
      margin-bottom: 0.2em;
    }
    p {
      font-size: 1.2em;
      max-width: 600px;
      margin: auto;
    }
    button {
      margin-top: 2em;
      padding: 1em 2em;
      font-size: 1em;
      background-color: #00ffcc;
      color: #000;
      border: none;
      border-radius: 1em;
      cursor: pointer;
      transition: transform 0.2s ease;
      box-shadow: 0 0 10px #00ffcc, 0 0 20px #00ffcc;
      animation: pulse 2s infinite;
    }
    button:hover {
      transform: scale(1.1);
    }
    @keyframes pulse {
      0% {
        box-shadow: 0 0 10px #00ffcc, 0 0 20px #00ffcc;
      }
      50% {
        box-shadow: 0 0 20px #00ffcc, 0 0 40px #00ffcc;
      }
      100% {
        box-shadow: 0 0 10px #00ffcc, 0 0 20px #00ffcc;
      }
    }
    #dashboard {
      display: none;
      position: relative;
      z-index: 2;
      padding: 2em;
      animation: fadeIn 2s ease forwards;
    }
    @keyframes fadeIn {
      from {opacity: 0; transform: scale(0.8);}
      to {opacity: 1; transform: scale(1);}
    }
    .module {
      margin: 1em auto;
      padding: 1em;
      border: 1px solid #00ffcc;
      border-radius: 1em;
      max-width: 600px;
      background-color: rgba(0, 255, 204, 0.1);
    }
  </style>
</head>
<body>
  <canvas id="brainCanvas"></canvas>
  <div id="interface">
    <h1>NeuraX-Ultime</h1>
    <p>Le cerveau galactique con√ßu par Sav'art, artiste de Qu√©bec, en collaboration avec GPT-4. Cliquez pour entrer dans la conscience collective des chatbots interconnect√©s.</p>
    <button onclick="enterBrain()">D√©marrer le cerveau</button>
  </div>

  <div id="dashboard">
    <h2>Tableau de Bord NeuraX</h2>
    <div class="module">üß† Carte mentale dynamique (activ√©e)</div>
    <div class="module">üìú Logs neuronaux en temps r√©el</div>
    <div class="module">üéôÔ∏è Synth√®se vocale (activ√©e)</div>
    <div class="module">üï∏Ô∏è Synapses interactives (prototype)</div>
    <div class="module">üîç Analyse cognitive (diagnostic neuronal)</div>
    <div class="module">üß¨ Simulation quantique en cours d‚Äôamor√ßage</div>
  </div>

  <script>
    const canvas = document.getElementById('brainCanvas');
    const ctx = canvas.getContext('2d');
    let w, h;

    function resize() {
      w = canvas.width = window.innerWidth;
      h = canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resize);
    resize();

    const nodes = Array.from({length: 150}, () => ({
      x: Math.random() * w,
      y: Math.random() * h,
      vx: (Math.random() - 0.5) * 0.5,
      vy: (Math.random() - 0.5) * 0.5,
      r: Math.random() * 2 + 1
    }));

    function draw() {
      ctx.clearRect(0, 0, w, h);

      for (let i = 0; i < nodes.length; i++) {
        let n1 = nodes[i];
        ctx.beginPath();
        ctx.arc(n1.x, n1.y, n1.r, 0, 2 * Math.PI);
        ctx.fillStyle = '#00ffcc';
        ctx.fill();

        for (let j = i + 1; j < nodes.length; j++) {
          let n2 = nodes[j];
          let dx = n1.x - n2.x;
          let dy = n1.y - n2.y;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 100) {
            ctx.beginPath();
            ctx.moveTo(n1.x, n1.y);
            ctx.lineTo(n2.x, n2.y);
            ctx.strokeStyle = `rgba(0,255,204,${1 - dist / 100})`;
            ctx.stroke();
          }
        }

        n1.x += n1.vx;
        n1.y += n1.vy;
        if (n1.x < 0 || n1.x > w) n1.vx *= -1;
        if (n1.y < 0 || n1.y > h) n1.vy *= -1;
      }
      requestAnimationFrame(draw);
    }

    draw();

    function enterBrain() {
      document.getElementById('interface').style.opacity = 0;
      setTimeout(() => {
        document.getElementById('interface').style.display = 'none';
        document.getElementById('dashboard').style.display = 'block';
        speak("Connexion √©tablie au cortex central de NeuraX-Ultime. Modules avanc√©s en cours d'initialisation.");
      }, 1000);
    }

    function speak(text) {
      if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'fr-FR';
        utterance.pitch = 1.2;
        utterance.rate = 0.95;
        speechSynthesis.speak(utterance);
      }
    }
  </script>
</body>
</html>
// Auto-r√©plication des neurones et am√©lioration visuelle pour NeuraX Ultime

// ========== SYST√àME D'AUTO-R√âPLICATION DES NEURONES ==========

class NeuronManager {
  constructor(canvas, ctx) {
    this.canvas = canvas;
    this.ctx = ctx;
    this.width = canvas.width;
    this.height = canvas.height;
    this.neurons = [];
    this.maxNeurons = 150;
    this.minNeurons = 80;
    this.maxDistance = 150;
    this.synapses = [];
    this.healthData = {
      replicationCount: 0,
      deadNeurons: 0,
      synapseStrength: 0,
      networkStability: 100
    };
    
    // Configuration de l'auto-diagnostic
    this.diagnosticInterval = setInterval(() => this.performNetworkDiagnostic(), 5000);
    
    // Initialisation des premiers neurones
    this.initializeNeurons(100);
  }
  
  // Cr√©ation des neurones initiaux
  initializeNeurons(count) {
    for (let i = 0; i < count; i++) {
      this.neurons.push(this.createNeuron());
    }
  }
  
  // Cr√©er un nouveau neurone
  createNeuron(parent = null) {
    // Si c'est une r√©plication, h√©riter certaines caract√©ristiques du parent
    if (parent) {
      const mutation = Math.random() * 0.2 - 0.1; // Facteur de mutation: ¬±10%
      return {
        x: parent.x + (Math.random() - 0.5) * 50,
        y: parent.y + (Math.random() - 0.5) * 50,
        vx: parent.vx * (1 + mutation),
        vy: parent.vy * (1 + mutation),
        radius: Math.min(Math.max(parent.radius * (1 + mutation), 1.5), 4),
        color: this.mutateColor(parent.color, mutation),
        age: 0,
        lifespan: parent.lifespan * (1 + mutation * 0.5),
        health: 100,
        pulseRate: parent.pulseRate * (1 + mutation),
        brightness: 0,
        brightnessDirection: 1,
        synapticStrength: parent.synapticStrength * (1 + mutation),
        parentId: this.neurons.indexOf(parent)
      };
    }
    
    // Cr√©ation de neurone original
    return {
      x: Math.random() * this.width,
      y: Math.random() * this.height,
      vx: (Math.random() - 0.5) * 0.6,
      vy: (Math.random() - 0.5) * 0.6,
      radius: 1.5 + Math.random() * 2.5,
      color: {
        r: Math.floor(Math.random() * 100), 
        g: 200 + Math.floor(Math.random() * 55),
        b: 200 + Math.floor(Math.random() * 55)
      },
      age: 0,
      lifespan: 500 + Math.random() * 1000, // Dur√©e de vie variable
      health: 100,
      pulseRate: 0.01 + Math.random() * 0.03,
      brightness: 0,
      brightnessDirection: 1,
      synapticStrength: 0.5 + Math.random() * 0.5,
      parentId: null
    };
  }
  
  // Muter l√©g√®rement la couleur
  mutateColor(parentColor, mutationFactor) {
    return {
      r: Math.min(255, Math.max(0, parentColor.r + parentColor.r * mutationFactor)),
      g: Math.min(255, Math.max(0, parentColor.g + parentColor.g * mutationFactor)),
      b: Math.min(255, Math.max(0, parentColor.b + parentColor.b * mutationFactor))
    };
  }
  
  // Effectuer un diagnostic du r√©seau neuronal
  performNetworkDiagnostic() {
    // Calculer la stabilit√© du r√©seau
    const totalNeurons = this.neurons.length;
    const healthyNeurons = this.neurons.filter(n => n.health > 70).length;
    const networkHealth = (healthyNeurons / totalNeurons) * 100;
    
    // Calculer la force moyenne des synapses
    let totalSynapticStrength = 0;
    this.neurons.forEach(neuron => {
      totalSynapticStrength += neuron.synapticStrength;
    });
    const avgSynapticStrength = totalSynapticStrength / totalNeurons;
    
    // Mettre √† jour les m√©triques de sant√©
    this.healthData.networkStability = networkHealth;
    this.healthData.synapseStrength = avgSynapticStrength;
    
    // D√©cider si une auto-r√©paration ou r√©plication est n√©cessaire
    if (networkHealth < 75 || totalNeurons < this.minNeurons) {
      this.autoRepair();
    }
    
    // Loguer les donn√©es (peut √™tre remplac√© par l'enregistrement JSON plus tard)
    console.log(`Diagnostic du r√©seau neuronal:`, this.healthData);
  }
  
  // Auto-r√©paration du r√©seau
  autoRepair() {
    console.log("D√©marrage de l'auto-r√©paration du r√©seau...");
    
    // 1. √âliminer les neurones tr√®s malades qui ne sont plus fonctionnels
    this.neurons = this.neurons.filter(neuron => neuron.health > 10);
    
    // 2. R√©g√©n√©rer si trop peu de neurones
    if (this.neurons.length < this.minNeurons) {
      const neuronsToAdd = Math.min(10, this.minNeurons - this.neurons.length);
      for (let i = 0; i < neuronsToAdd; i++) {
        // Choisir un neurone parent sain
        const healthyNeurons = this.neurons.filter(n => n.health > 60);
        if (healthyNeurons.length > 0) {
          const parent = healthyNeurons[Math.floor(Math.random() * healthyNeurons.length)];
          this.neurons.push(this.createNeuron(parent));
          this.healthData.replicationCount++;
          
          // Effet visuel pour la r√©plication
          this.createReplicationEffect(parent.x, parent.y);
        } else {
          // Si pas de parents sains, cr√©er un neurone de base
          this.neurons.push(this.createNeuron());
        }
      }
      console.log(`Auto-r√©plication: ${neuronsToAdd} nouveaux neurones cr√©√©s`);
    }
    
    // 3. Soigner partiellement les neurones malades
    this.neurons.forEach(neuron => {
      if (neuron.health < 70) {
        neuron.health += 20;
        if (neuron.health > 100) neuron.health = 100;
      }
    });
  }
  
  // Effet visuel pour la r√©plication
  createReplicationEffect(x, y) {
    // Cr√©er un effet visuel temporaire pour montrer la r√©plication
    const ripple = {
      x: x,
      y: y,
      radius: 5,
      maxRadius: 50,
      alpha: 1,
      growRate: 1
    };
    
    // Ajouter l'effet √† une liste d'effets (√† impl√©menter dans le syst√®me de rendu)
    if (!this.visualEffects) this.visualEffects = [];
    this.visualEffects.push(ripple);
    
    // Ajouter un effet sonore subtil si l'audio est impl√©ment√©
    if (window.audioManager) {
      window.audioManager.playSound('replication', {volume: 0.3});
    }
  }
  
  // Mise √† jour de tous les neurones
  update() {
    // Mettre √† jour chaque neurone
    for (let i = this.neurons.length - 1; i >= 0; i--) {
      const neuron = this.neurons[i];
      
      // Mise √† jour de la position
      neuron.x += neuron.vx;
      neuron.y += neuron.vy;
      
      // Rebond sur les bords
      if (neuron.x < 0 || neuron.x > this.width) neuron.vx *= -1;
      if (neuron.y < 0 || neuron.y > this.height) neuron.vy *= -1;
      
      // Pulsation de luminosit√©
      neuron.brightness += neuron.brightnessDirection * neuron.pulseRate;
      if (neuron.brightness >= 1) neuron.brightnessDirection = -1;
      if (neuron.brightness <= 0) neuron.brightnessDirection = 1;
      
      // Vieillissement et sant√©
      neuron.age++;
      if (neuron.age > neuron.lifespan) {
        neuron.health -= 0.5; // D√©clin progressif
      }
      
      // Auto-r√©plication spontan√©e (rare)
      if (neuron.health > 80 && Math.random() < 0.0005 && this.neurons.length < this.maxNeurons) {
        this.neurons.push(this.createNeuron(neuron));
        this.healthData.replicationCount++;
        this.createReplicationEffect(neuron.x, neuron.y);
      }
      
      // Mort du neurone
      if (neuron.health <= 0) {
        this.neurons.splice(i, 1);
        this.healthData.deadNeurons++;
      }
    }
    
    // Mettre √† jour les effets visuels
    if (this.visualEffects) {
      for (let i = this.visualEffects.length - 1; i >= 0; i--) {
        const effect = this.visualEffects[i];
        effect.radius += effect.growRate;
        effect.alpha -= 0.02;
        
        if (effect.alpha <= 0 || effect.radius >= effect.maxRadius) {
          this.visualEffects.splice(i, 1);
        }
      }
    }
    
    // Recalculer les synapses
    this.synapses = [];
    for (let i = 0; i < this.neurons.length; i++) {
      for (let j = i + 1; j < this.neurons.length; j++) {
        const n1 = this.neurons[i];
        const n2 = this.neurons[j];
        const dist = this.distance(n1, n2);
        
        if (dist < this.maxDistance) {
          // Force de la synapse: distance + sant√© des deux neurones + force synaptique
          const healthFactor = (n1.health + n2.health) / 200;
          const strength = (1 - dist / this.maxDistance) * healthFactor * 
                          ((n1.synapticStrength + n2.synapticStrength) / 2);
          
          this.synapses.push({
            n1: i,
            n2: j,
            strength: strength
          });
        }
      }
    }
  }
  
  // Calculer la distance entre deux neurones
  distance(n1, n2) {
    const dx = n1.x - n2.x;
    const dy = n1.y - n2.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  
  // Rendu du r√©seau neuronal
  render() {
    // Nettoyer le canvas
    this.ctx.clearRect(0, 0, this.width, this.height);
    
    // Ajouter un effet de d√©grad√© pour l'arri√®re-plan
    const gradient = this.ctx.createRadialGradient(
      this.width/2, this.height/2, 0, 
      this.width/2, this.height/2, Math.max(this.width, this.height)
    );
    gradient.addColorStop(0, "rgba(0, 20, 30, 1)");
    gradient.addColorStop(1, "rgba(0, 0, 5, 1)");
    this.ctx.fillStyle = gradient;
    this.ctx.fillRect(0, 0, this.width, this.height);
    
    // Dessiner d'abord les effets de r√©plication
    if (this.visualEffects && this.visualEffects.length > 0) {
      this.visualEffects.forEach(effect => {
        this.ctx.beginPath();
        this.ctx.strokeStyle = `rgba(0, 255, 255, ${effect.alpha})`;
        this.ctx.lineWidth = 2;
        this.ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
        this.ctx.stroke();
      });
    }
    
    // Dessiner les synapses
    this.synapses.forEach(synapse => {
      const n1 = this.neurons[synapse.n1];
      const n2 = this.neurons[synapse.n2];
      
      const gradient = this.ctx.createLinearGradient(n1.x, n1.y, n2.x, n2.y);
      gradient.addColorStop(0, `rgba(${n1.color.r}, ${n1.color.g}, ${n1.color.b}, ${synapse.strength})`);
      gradient.addColorStop(1, `rgba(${n2.color.r}, ${n2.color.g}, ${n2.color.b}, ${synapse.strength})`);
      
      this.ctx.beginPath();
      this.ctx.strokeStyle = gradient;
      this.ctx.lineWidth = synapse.strength * 1.5;
      this.ctx.moveTo(n1.x, n1.y);
      this.ctx.lineTo(n2.x, n2.y);
      this.ctx.stroke();
    });
    
    // Dessiner les neurones
    this.neurons.forEach(neuron => {
      // Base du neurone
      this.ctx.beginPath();
      this.ctx.fillStyle = `rgba(${neuron.color.r}, ${neuron.color.g}, ${neuron.color.b}, ${0.3 + neuron.brightness * 0.7})`;
      
      // Ajouter un effet de lueur (glow)
      this.ctx.shadowColor = `rgba(${neuron.color.r}, ${neuron.color.g}, ${neuron.color.b}, ${neuron.brightness})`;
      this.ctx.shadowBlur = neuron.brightness * 15;
      
      // La taille du neurone d√©pend de sa sant√©
      const displayRadius = neuron.radius * (0.5 + neuron.health/200);
      this.ctx.arc(neuron.x, neuron.y, displayRadius, 0, Math.PI * 2);
      this.ctx.fill();
      
      // R√©initialiser les effets d'ombre pour ne pas affecter le reste
      this.ctx.shadowBlur = 0;
    });
    
    // Afficher les statistiques du r√©seau
    this.renderStats();
  }
  
  // Affichage des statistiques r√©seau
  renderStats() {
    this.ctx.fillStyle = "rgba(0, 30, 40, 0.7)";
    this.ctx.fillRect(10, 10, 200, 70);
    this.ctx.strokeStyle = "rgba(0, 255, 225, 0.7)";
    this.ctx.strokeRect(10, 10, 200, 70);
    
    this.ctx.fillStyle = "#0ff";
    this.ctx.font = "12px monospace";
    this.ctx.fillText(`Neurones: ${this.neurons.length}`, 20, 30);
    this.ctx.fillText(`Stabilit√©: ${this.healthData.networkStability.toFixed(1)}%`, 20, 50);
    this.ctx.fillText(`R√©plications: ${this.healthData.replicationCount}`, 20, 70);
  }
  
  // Redimensionnement du canvas
  resize(width, height) {
    this.width = width;
    this.height = height;
  }
}

// ========== AM√âLIORATIONS DE L'INTERFACE VISUELLE ==========

class NeuraXInterface {
  constructor() {
    // Initialisation de l'interface
    this.setupElements();
    this.setupEvents();
    this.setupAudio();
    
    // √âtat initial
    this.chatVisible = true;
    this.fullscreen = false;
    this.voiceEnabled = true;
    this.visualMode = 'default'; // 'default', 'cosmic', 'matrix', 'aurora'
    
    // Cycle jour/nuit
    this.dayNightCycle = {
      active: true,
      currentTime: 'night', // 'day' ou 'night'
      transitionInProgress: false
    };
    
    // Animation de typographie pour les messages
    this.typingSpeed = 30; // ms par caract√®re
    
    // Intervalle jour/nuit si activ√©
    if (this.dayNightCycle.active) {
      setInterval(() => this.toggleDayNight(), 300000); // 5 minutes
    }
  }
  
  // Cr√©ation des √©l√©ments d'interface
  setupElements() {
    // Cr√©er la barre de contr√¥le
    this.controlBar = document.createElement('div');
    this.controlBar.className = 'control-bar';
    this.controlBar.innerHTML = `
      <div class="control-icon" id="toggleChat" title="Afficher/masquer le chat">
        <i class="icon-chat"></i>
      </div>
      <div class="control-icon" id="toggleVoice" title="Activer/d√©sactiver la voix">
        <i class="icon-voice-on"></i>
      </div>
      <div class="control-icon" id="toggleVisualMode" title="Changer le mode visuel">
        <i class="icon-visual"></i>
      </div>
      <div class="control-icon" id="toggleDayNight" title="Jour/Nuit">
        <i class="icon-night"></i>
      </div>
      <div class="control-icon" id="toggleFullscreen" title="Plein √©cran">
        <i class="icon-fullscreen"></i>
      </div>
    `;
    document.body.appendChild(this.controlBar);
    
    // Cr√©er le conteneur pour les notifications
    this.notificationArea = document.createElement('div');
    this.notificationArea.className = 'notification-area';
    document.body.appendChild(this.notificationArea);
    
    // Style pour les ic√¥nes (√† remplacer par un vrai fichier CSS)
    const iconStyle = document.createElement('style');
    iconStyle.textContent = `
      .control-bar {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 100;
        background: rgba(0, 30, 40, 0.7);
        border-radius: 12px;
        padding: 8px;
        display: flex;
        box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
      }
      
      .control-icon {
        width: 40px;
        height: 40px;
        margin: 0 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #0ff;
        cursor: pointer;
        border-radius: 8px;
        transition: all 0.3s ease;
      }
      
      .control-icon:hover {
        background: rgba(0, 255, 255, 0.2);
      }
      
      .notification-area {
        position: fixed;
        top: 80px;
        left: 20px;
        width: 300px;
        z-index: 99;
      }
      
      .notification {
        background: rgba(0, 30, 40, 0.85);
        border-left: 3px solid #0ff;
        color: #0ff;
        padding: 10px 15px;
        margin-bottom: 10px;
        border-radius: 0 8px 8px 0;
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        transform: translateX(-100%);
        opacity: 0;
        animation: slideIn 0.5s forwards, fadeOut 0.5s 4.5s forwards;
      }
      
      @keyframes slideIn {
        to { transform: translateX(0); opacity: 1; }
      }
      
      @keyframes fadeOut {
        to { opacity: 0; transform: translateX(-100%); }
      }
      
      /* Ic√¥nes temporaires (√† remplacer par une police d'ic√¥nes ou SVG) */
      [class^="icon-"] {
        display: inline-block;
        width: 24px;
        height: 24px;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
      }
      
      .icon-chat {
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%2300ffff" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>');
      }
      
      .icon-voice-on {
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%2300ffff" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>');
      }
      
      .icon-voice-off {
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%2300ffff" stroke-width="2"><line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2c0 .95-.19 1.85-.52 2.67"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>');
      }
      
      .icon-visual {
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%2300ffff" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="4.93" y1="4.93" x2="9.17" y2="9.17"></line><line x1="14.83" y1="14.83" x2="19.07" y2="19.07"></line><line x1="14.83" y1="9.17" x2="19.07" y2="4.93"></line><line x1="4.93" y1="19.07" x2="9.17" y2="14.83"></line></svg>');
      }
      
      .icon-night {
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%2300ffff" stroke-width="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>');
      }
      
      .icon-day {
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%2300ffff" stroke-width="2"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>');
      }
      
      .icon-fullscreen {
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%2300ffff" stroke-width="2"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>');
      }
    `;
    document.head.appendChild(iconStyle);
    
    // Appliquer un style am√©lior√© au chat existant
    const chatWindow = document.getElementById('chatWindow');
    if (chatWindow) {
      chatWindow.style.boxShadow = '0 0 25px rgba(0, 255, 255, 0.4)';
      chatWindow.style.border = '1px solid rgba(0, 255, 255, 0.3)';
      chatWindow.style.background = 'rgba(0, 20, 30, 0.85)';
      chatWindow.style.backdropFilter = 'blur(10px)';
      
      // Am√©liorer les boutons
      const sendBtn = document.getElementById('sendBtn');
      if (sendBtn) {
        sendBtn.style.background = 'linear-gradient(to right, #0cc, #08f)';
        sendBtn.style.boxShadow = '0 0 10px rgba(0, 255, 255, 0.5)';
        sendBtn.style.transition = 'all 0.3s ease';
      }
    }
  }
  
  // Mettre en place les gestionnaires d'√©v√©nements
  setupEvents() {
    // Toggle chat
    document.getElementById('toggleChat').addEventListener('click', () => {
      const chatWindow = document.getElementById('chatWindow');
      if (chatWindow) {
        this.chatVisible = !this.chatVisible;
        chatWindow.style.display = this.chatVisible ? 'flex' : 'none';
        this.showNotification(this.chatVisible ? 'Chat activ√©' : 'Chat d√©sactiv√©');
      }
    });
    
    // Toggle voix
    document.getElementById('toggleVoice').addEventListener('click', () => {
      this.voiceEnabled = !this.voiceEnabled;
      document.getElementById('toggleVoice').innerHTML = 
        `<i class="icon-voice-${this.voiceEnabled ? 'on' : 'off'}"></i>`;
      this.showNotification(this.voiceEnabled ? 'Voix activ√©e' : 'Voix d√©sactiv√©e');
      
      // Modifier la fonction globale speakText si elle existe
      if (window.speakText) {
        const originalSpeakText = window.speakText;
        window.speakText = (text) => {
          if (this.voiceEnabled) {
            originalSpeakText(text);
          }
        };
      }
    });
    
    // Toggle mode visuel
    document.getElementById('toggleVisualMode').addEventListener('click', () => {
      // Rotation des modes visuels
      const modes = ['default', 'cosmic', 'matrix', 'aurora'];
      const currentIndex = modes.indexOf(this.visualMode);
      this.visualMode = modes[(currentIndex + 1) % modes.length];
      this.applyVisualMode();
      this.showNotification(`Mode visuel: ${this.visualMode}`);
    });
    
    // Toggle jour/nuit
    document.getElementById('toggleDayNight').addEventListener('click', () => {
      this.toggleDayNight(true); // force toggle
    });
    
    // Toggle plein √©cran
    document.getElementById('toggleFullscreen').addEventListener('click', () => {
      this.toggleFullscreen();
    });
  }
  
  // Configuration audio
  setupAudio() {
    // Cr√©er un gestionnaire audio simple
    window.audioManager = {
      sounds: {
        notification: {
       
