# permission_system/core.py
from enum import Enum, auto
from typing import Dict, List, Set, Optional, Union, Any
from dataclasses import dataclass, field
import json
import time
from datetime import datetime, timedelta
import uuid


class UserCategory(Enum):
    """Catégories principales d'utilisateurs"""
    RESEARCHER = auto()
    ENTERPRISE = auto()
    PUBLIC = auto()


class ResearcherLevel(Enum):
    """Niveaux de chercheurs"""
    JUNIOR = auto()
    SENIOR = auto()
    PRINCIPAL = auto()


class EnterpriseRole(Enum):
    """Rôles en entreprise"""
    ANALYST = auto()
    DEVELOPER = auto()
    DECISION_MAKER = auto()
    ADMINISTRATOR = auto()


class PublicTier(Enum):
    """Niveaux utilisateurs publics"""
    STANDARD = auto()
    PREMIUM = auto()
    CREATOR = auto()


class PermissionLevel(Enum):
    """Niveaux d'accès aux fonctionnalités"""
    NONE = 0
    VIEW = 10
    USE = 20
    MODIFY = 30
    MANAGE = 40
    ADMIN = 50


@dataclass
class UserAttributes:
    """Attributs contextuels de l'utilisateur"""
    geographic_location: str
    data_sensitivity_clearance: int  # 1-5, 5 étant le plus haut niveau
    expertise_score: int  # 1-100
    usage_history: Dict[str, int] = field(default_factory=dict)  # fonctionnalité -> nombre d'utilisations
    time_constraints: Dict[str, Any] = field(default_factory=dict)  # contraintes temporelles


@dataclass
class UserRole:
    """Définition du rôle utilisateur"""
    user_category: UserCategory
    specific_role: Union[ResearcherLevel, EnterpriseRole, PublicTier]
    attributes: UserAttributes
    additional_roles: List[str] = field(default_factory=list)


@dataclass
class Feature:
    """Définition d'une fonctionnalité"""
    id: str
    name: str
    category: str
    subcategory: str
    min_data_sensitivity: int  # Niveau de sensibilité minimum requis
    min_expertise: int  # Niveau d'expertise minimum requis
    parent_feature_id: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Permission:
    """Permission associant un rôle à une fonctionnalité"""
    role_category: UserCategory
    specific_role: Union[ResearcherLevel, EnterpriseRole, PublicTier]
    feature_id: str
    level: PermissionLevel
    conditions: Dict[str, Any] = field(default_factory=dict)
    expiry: Optional[datetime] = None


@dataclass
class TemporaryAccess:
    """Accès temporaire à une fonctionnalité"""
    user_id: str
    feature_id: str
    level: PermissionLevel
    granted_by: str
    reason: str
    created_at: datetime = field(default_factory=datetime.now)
    expires_at: Optional[datetime] = None
    access_id: str = field(default_factory=lambda: str(uuid.uuid4()))


class PermissionMatrix:
    """Matrice de permissions liant rôles et fonctionnalités"""
    
    def __init__(self):
        self.permissions: List[Permission] = []
        self.features: Dict[str, Feature] = {}
        self.temporary_accesses: List[TemporaryAccess] = []
    
    def add_feature(self, feature: Feature) -> None:
        """Ajoute une fonctionnalité au système"""
        self.features[feature.id] = feature
    
    def add_permission(self, permission: Permission) -> None:
        """Ajoute une permission à la matrice"""
        self.permissions.append(permission)
    
    def get_permission_level(self, user_role: UserRole, feature_id: str) -> PermissionLevel:
        """Détermine le niveau de permission pour un rôle et une fonctionnalité"""
        highest_level = PermissionLevel.NONE
        
        # Vérifier les permissions standards
        for permission in self.permissions:
            if (permission.role_category == user_role.user_category and 
                permission.specific_role == user_role.specific_role and
                permission.feature_id == feature_id):
                
                # Vérifier si la permission a expiré
                if permission.expiry and datetime.now() > permission.expiry:
                    continue
                
                # Vérifier les conditions contextuelles
                if self._check_conditions(permission.conditions, user_role.attributes):
                    highest_level = max(highest_level, permission.level)
        
        return highest_level
    
    def _check_conditions(self, conditions: Dict[str, Any], attributes: UserAttributes) -> bool:
        """Vérifie si les attributs de l'utilisateur respectent les conditions"""
        # Implémentation simplifiée - à développer selon les besoins spécifiques
        if 'min_expertise' in conditions and attributes.expertise_score < conditions['min_expertise']:
            return False
        
        if 'allowed_locations' in conditions and attributes.geographic_location not in conditions['allowed_locations']:
            return False
            
        if 'min_data_clearance' in conditions and attributes.data_sensitivity_clearance < conditions['min_data_clearance']:
            return False
            
        return T<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>neuraX-ultime - Le Cerveau Virtuel</title>
<style>
  body, html {
    margin: 0; padding: 0; height: 100%;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
    color: #eee;
    display: flex;
    flex-direction: column;
  }
  header {
    padding: 1rem; text-align: center;
    background: rgba(15,32,39,0.9);
    font-weight: 700;
    font-size: 1.5rem;
    letter-spacing: 0.1em;
    border-bottom: 1px solid #1f3a4a;
  }
  main {
    flex: 1;
    display: flex;
    overflow: hidden;
  }
  #chat-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 1rem;
  }
  #chat-window {
    flex: 1;
    background: rgba(0,0,0,0.3);
    border-radius: 10px;
    padding: 1rem;
    overflow-y: auto;
    font-size: 1rem;
    line-height: 1.4;
    display: flex;
    flex-direction: column;
  }
  .message {
    margin-bottom: 1rem;
    max-width: 70%;
    padding: 0.5rem 1rem;
    border-radius: 15px;
    word-wrap: break-word;
  }
  .user-message {
    background: #2196f3cc;
    align-self: flex-end;
    color: #fff;
  }
  .bot-message {
    background: #4caf50cc;
    align-self: flex-start;
    color: #fff;
  }
  form {
    margin-top: 1rem;
    display: flex;
    gap: 0.5rem;
  }
  input[type="text"] {
    flex: 1;
    padding: 0.7rem 1rem;
    font-size: 1rem;
    border-radius: 25px;
    border: none;
    outline: none;
  }
  button {
    background: #4caf50;
    border: none;
    color: white;
    padding: 0 1.5rem;
    border-radius: 25px;
    cursor: pointer;
    font-weight: 700;
    transition: background 0.3s ease;
  }
  button:hover {
    background: #388e3c;
  }
  #neural-canvas {
    width: 400px;
    background: #0a1a2b;
    border-radius: 10px;
    margin: 1rem;
  }
  footer {
    text-align: center;
    padding: 0.5rem;
    font-size: 0.8rem;
    color: #777;
    background: rgba(15,32,39,0.9);
    border-top: 1px solid #1f3a4a;
  }
  @media(max-width: 900px) {
    main {
      flex-direction: column;
    }
    #neural-canvas {
      width: 100%;
      height: 200px;
      margin: 0.5rem 0 1rem 0;
    }
  }
</style>
</head>
<body>

<header>neuraX-ultime — Le Cerveau Virtuel</header>

<main>
  <section id="chat-section" aria-label="Section de chat">
    <div id="chat-window" aria-live="polite" aria-label="Conversation avec neuraX"></div>
    <form id="chat-form" autocomplete="off" aria-label="Formulaire de chat neuraX">
      <input type="text" id="user-input" placeholder="Parle à neuraX..." required />
      <button type="submit">Envoyer</button>
    </form>
  </section>

  <canvas id="neural-canvas" width="400" height="400" aria-label="Tableau de bord neuronal"></canvas>
</main>

<footer>
  Grand Architecte de l’univers virtuel — Ami
</footer>

<script>
  // --- Chatbot ---
  const chatWindow = document.getElementById('chat-window');
  const chatForm = document.getElementById('chat-form');
  const userInput = document.getElementById('user-input');

  function addMessage(text, sender) {
    const msgDiv = document.createElement('div');
    msgDiv.classList.add('message', sender === 'user' ? 'user-message' : 'bot-message');
    msgDiv.textContent = text;
    chatWindow.appendChild(msgDiv);
    chatWindow.scrollTop = chatWindow.scrollHeight;
  }

  // Synthèse vocale
  function speak(text) {
    if (!window.speechSynthesis) return;
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.lang = 'fr-FR';
    utterance.rate = 1;
    utterance.pitch = 1.1;
    window.speechSynthesis.speak(utterance);
  }

  // Simulation d’appel à GPT-4 (à remplacer par un backend réel)
  async function getBotResponse(input) {
    return new Promise(resolve => {
      setTimeout(() => {
        resolve(`neuraX répond : "${input.split('').reverse().join('')}" — La lumière vient du questionnement.`);
      }, 900);
    });
  }

  chatForm.addEventListener('submit', async e => {
    e.preventDefault();
    const inputText = userInput.value.trim();
    if (!inputText) return;
    addMessage(inputText, 'user');
    userInput.value = '';
    userInput.disabled = true;

    const botReply = await getBotResponse(inputText);
    addMessage(botReply, 'bot');
    speak(botReply);
    userInput.disabled = false;
    userInput.focus();

    pulseNode();
  });

  addMessage("Bienvenue dans le cerveau de neuraX-ultime. Pose ta question, et laisse l'univers s'éclairer.", 'bot');

  // --- Tableau neuronal ---
  const canvas = document.getElementById('neural-canvas');
  const ctx = canvas.getContext('2d');
  let width = canvas.width;
  let height = canvas.height;

  const nodes = Array.from({length: 10}, () => ({
    x: Math.random() * width * 0.9 + width * 0.05,
    y: Math.random() * height * 0.9 + height * 0.05,
    radius: 10,
    baseRadius: 10,
    pulse: 0
  }));

  function draw() {
    ctx.clearRect(0, 0, width, height);

    // Connexions neuronales
    ctx.strokeStyle = 'rgba(0,255,255,0.3)';
    ctx.lineWidth = 1;
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i+1; j < nodes.length; j++) {
        const n1 = nodes[i], n2 = nodes[j];
        const dist = Math.hypot(n1.x - n2.x, n1.y - n2.y);
        if (dist < 180) {
          ctx.beginPath();
          ctx.moveTo(n1.x, n1.y);
          ctx.lineTo(n2.x, n2.y);
          ctx.stroke();
        }
      }
    }

    // Dessin des neurones avec pulsation
    nodes.forEach(n => {
      if (n.pulse > 0) {
        n.radius = n.baseRadius + Math.sin(n.pulse) * 4;
        n.pulse += 0.15;
        if (n.pulse > Math.PI * 2) {
          n.pulse = 0;
          n.radius = n.baseRadius;
        }
      }

      ctx.beginPath();
      ctx.arc(n.x, n.y, n.radius, 0, 2 * Math.PI);
      const gradient = ctx.createRadialGradient(n.x, n.y, n.radius * 0.3, n.x, n.y, n.radius);
      gradient.addColorStop(0, 'aqua');
      gradient.addColorStop(1, 'transparent');
      ctx.fillStyle = gradient;
      ctx.shadowColor = 'aqua';
      ctx.shadowBlur = 15;
      ctx.fill();
    });

    requestAnimationFrame(draw);
  }

  // Pulsation + message dans le chat
  function pulseNode() {
    // Neurone au hasard
    const node = nodes[Math.floor(Math.random() * nodes.length)];
    node.pulse = 0.1;

    // Message discret dans le chat
    const pulseMsg = document.createElement('div');
    pulseMsg.classList.add('bot-message');
    pulseMsg.style.fontStyle = 'italic';
    pulseMsg.style.opacity = '0.7';
    pulseMsg.textContent = '⚡ neuraX vibre... ⚡';
    chatWindow.appendChild(pulseMsg);
    chatWindow.scrollTop = chatWindow.scrollHeight;

    // Disparition progressive
    setTimeout(() => {
      pulseMsg.style.transition = 'opacity 1s ease';
      pulseMsg.style.opacity = '0';
      setTimeout(() => pulseMsg.remove(), 1000);
    }, 2000);
  }

  draw();
</script
!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NeuraX-Ultime | Le Cerveau Vivant</title>
  <style>
    body {
      margin: 0;
      background: radial-gradient(ellipse at center, #000014 0%, #000010 100%);
      overflow: hidden;
      font-family: 'Orbitron', sans-serif;
      color: #00ffcc;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }
    #interface {
      position: relative;
      z-index: 1;
      text-align: center;
      margin-top: 10vh;
    }
    h1 {
      font-size: 3em;
      margin-bottom: 0.2em;
    }
    p {
      font-size: 1.2em;
      max-width: 600px;
      margin: auto;
    }
    button {
      margin-top: 2em;
      padding: 1em 2em;
      font-size: 1em;
      background-color: #00ffcc;
      color: #000;
      border: none;
      border-radius: 1em;
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    button:hover {
      transform: scale(1.1);
    }
  </style>
</head>
<body>
  <canvas id="brainCanvas"></canvas>
  <div id="interface">
    <h1>NeuraX-Ultime</h1>
    <p>Le cerveau galactique conçu par Sav'art, artiste de Québec, en collaboration avec GPT-4. Cliquez pour entrer dans la conscience collective des chatbots interconnectés.</p>
    <button onclick="enterBrain()">Démarrer le cerveau</button>
  </div>

  <script>
    const canvas = document.getElementById('brainCanvas');
    const ctx = canvas.getContext('2d');
    let w, h;


















    function resize() {
      w = canvas.width = window.innerWidth;
      h = canvas.height = window.innerHeight;
    }

    window.addEventListener('resize', resize);
    resize();

    const nodes = Array.from({length: 150}, () => ({
      x: Math.random() * w,
      y: Math.random() * h,
      vx: (Math.random() - 0.5) * 0.5,
      vy: (Math.random() - 0.5) * 0.5,
      r: Math.random() * 2 + 1
    }));

    function draw() {
      ctx.clearRect(0, 0, w, h);

      for (let i = 0; i < nodes.length; i++) {
        let n1 = nodes[i];
        ctx.beginPath();
        ctx.arc(n1.x, n1.y, n1.r, 0, 2 * Math.PI);
        ctx.fillStyle = '#00ffcc';
        ctx.fill();

        for (let j = i + 1; j < nodes.length; j++) {
          let n2 = nodes[j];
          let dx = n1.x - n2.x;
          let dy = n1.y - n2.y;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 100) {
            ctx.beginPath();
            ctx.moveTo(n1.x, n1.y);
            ctx.lineTo(n2.x, n2.y);
            ctx.strokeStyle = `rgba(0,255,204,${1 - dist / 100})`;
            ctx.stroke();
          }
        }

        n1.x += n1.vx;
        n1.y += n1.vy;
        if (n1.x < 0 || n1.x > w) n1.vx *= -1;
        if (n1.y < 0 || n1.y > h) n1.vy *= -1;
      }
      requestAnimationFrame(draw);
    }

    draw();


    function enterBrain() {
      window.location.href = "./interface.html";
    }



  </script>
</body>
</html>
