<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuraX-Ultime : Simulation Neuronale</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        /* Custom styles for the selected vibrant palette - "Energetic & Playful" (Yellow, Teal, Purple) */
        :root {
            --color-primary: #00CED1; /* Teal */
            --color-secondary: #FFD700; /* Yellow */
            --color-accent: #8A2BE2; /* Purple */
            --color-text-dark: #333;
            --color-text-light: #fefefe;
            --color-bg-light: #f8f8f8;
            --color-bg-dark: #2d3748; /* For darker elements like sidebar */
        }
        body {
            background-color: var(--color-bg-light);
            color: var(--color-text-dark);
        }
        .header-bg {
            background-color: var(--color-primary);
        }
        .sidebar {
            background-color: var(--color-bg-dark); /* Darker background for sidebar */
            width: 250px;
            transform: translateX(-100%);
            transition: transform 0.3s ease-in-out;
            z-index: 100;
        }
        .sidebar.open {
            transform: translateX(0);
        }
        @media (min-width: 768px) {
            .sidebar {
                transform: translateX(0);
            }
            .main-content-area {
                margin-left: 250px; /* Adjust main content to sidebar width */
            }
        }

        .nav-item {
            color: var(--color-text-light);
            transition: background-color 0.2s ease;
        }
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .nav-item.active {
            background-color: var(--color-accent);
            font-weight: bold;
        }
        .btn-primary {
            background-color: var(--color-primary);
            color: var(--color-text-light);
        }
        .btn-primary:hover {
            background-color: #00BFFF; /* A slightly lighter teal */
        }
        .btn-secondary {
            background-color: #e2e8f0; /* Gray-200 */
            color: var(--color-text-dark);
        }
        .btn-secondary:hover {
            background-color: #cbd5e0; /* Gray-300 */
        }
        .progress-bar-fill {
            background-color: var(--color-accent);
        }
        .modal {
            background-color: rgba(0, 0, 0, 0.7);
        }
        .toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 1000;
        }
        .toast {
            background-color: var(--color-primary);
            color: var(--color-text-light);
        }
        .toast.success {
            background-color: #2ecc71; /* Green */
        }
        .toast.error {
            background-color: #e74c3c; /* Red */
        }
        .toast.info {
            background-color: #3498db; /* Blue */
        }
        .chat-message.user {
            background-color: var(--color-accent);
            color: var(--color-text-light);
            align-self: flex-end;
            border-bottom-right-radius: 0;
        }
        .chat-message.ai {
            background-color: var(--color-secondary);
            color: var(--color-text-dark);
            align-self: flex-start;
            border-bottom-left-radius: 0;
        }
        .thinking-indicator {
            display: flex;
            justify-content: flex-start;
            margin-bottom: 0.5rem;
        }
        .thinking-dot {
            width: 8px;
            height: 8px;
            background-color: #ccc;
            border-radius: 50%;
            margin: 0 2px;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .thinking-dot:nth-child(1) { animation-delay: -0.32s; }
        .thinking-dot:nth-child(2) { animation-delay: -0.16s; }
        .thinking-dot:nth-child(3) { animation-delay: 0s; }
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }
        .voice-active-dot {
            width: 10px;
            height: 10px;
            background-color: #2ecc71; /* Green for active */
            border-radius: 50%;
            display: inline-block;
            animation: pulse-voice 1.5s infinite ease-in-out;
        }
        @keyframes pulse-voice {
            0% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(46, 204, 113, 0); }
            100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); }
        }
        /* Canvas container styling for responsiveness */
        .canvas-container {
            position: relative;
            width: 100%;
            padding-top: 56.25%; /* 16:9 Aspect Ratio (height / width * 100%) */
            overflow: hidden;
            background-color: #f8f8f8;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 800px; /* Max width for readability on large screens */
            margin-left: auto;
            margin-right: auto;
        }
        .canvas-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        /* Styles for section content management */
        .content-section {
            display: none; /* Hidden by default */
        }
        .content-section.active {
            display: block; /* Shown when active */
        }
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

    </style>
</head>
<body class="flex flex-col md:flex-row min-h-screen">
    <aside id="sidebar" class="sidebar fixed inset-y-0 left-0 w-64 p-6 md:relative md:transform-none shadow-lg md:shadow-none transition-transform duration-300 ease-in-out flex flex-col items-center z-50">
        <div class="mb-8 text-center">
            <h2 class="text-3xl font-bold text-white mb-2">NeuraX-Ultime</h2>
            <p class="text-sm text-gray-300">Simulation de R√©seau Neuronal</p>
        </div>

        <nav class="flex-grow w-full">
            <ul>
                <li class="mb-2">
                    <a href="#overview" class="nav-item flex items-center p-3 rounded-lg text-lg active" data-target-content="overviewContent">
                        <span class="mr-3">üìä</span> Vue d'ensemble
                    </a>
                </li>
                <li class="mb-2">
                    <a href="#stats" class="nav-item flex items-center p-3 rounded-lg text-lg" data-target-content="statsContent">
                        <span class="mr-3">üìà</span> Statistiques
                    </a>
                </li>
                <li class="mb-2">
                    <a href="#config" class="nav-item flex items-center p-3 rounded-lg text-lg" data-target-content="configContent">
                        <span class="mr-3">‚öôÔ∏è</span> Configuration
                    </a>
                </li>
                <li class="mb-2">
                    <a href="#logs" class="nav-item flex items-center p-3 rounded-lg text-lg" data-target-content="logsContent">
                        <span class="mr-3">üìú</span> Journal
                    </a>
                </li>
            </ul>
        </nav>

        <div class="w-full mt-auto pt-6 border-t border-gray-700 text-sm text-gray-400 text-center">
            &copy; 2025 NeuraX Systems
        </div>
    </aside>

    <main class="main-content-area flex-grow p-4 md:p-8 relative">
        <button id="menuToggle" class="md:hidden fixed top-4 left-4 z-50 p-3 bg-gray-800 text-white rounded-lg shadow-lg">
            ‚ò∞
        </button>

        <div class="container mx-auto">
            <h1 class="text-4xl font-extrabold text-gray-800 mb-8 text-center">Bienvenue sur NeuraX-Ultime</h1>

            <div class="bg-white p-6 rounded-lg shadow-md mb-8">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">Contr√¥le Syst√®me</h2>
                <div class="flex flex-col md:flex-row items-center justify-between space-y-4 md:space-y-0 md:space-x-4">
                    <button id="startBtn" class="btn-primary py-3 px-6 rounded-full text-lg font-semibold shadow-lg hover:shadow-xl transition duration-300 ease-in-out flex-grow">
                        D√©marrer le Syst√®me NeuraX
                    </button>
                    <button id="deactivateBtn" class="btn-secondary py-3 px-6 rounded-full text-lg font-semibold shadow-md hover:shadow-lg transition duration-300 ease-in-out flex-grow hidden">
                        D√©sactiver le Syst√®me
                    </button>
                </div>
            </div>

            <div id="contentWrapper">
                <section id="overviewContent" class="content-section active grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div class="bg-white p-6 rounded-lg shadow-md flex flex-col">
                        <h2 class="text-2xl font-bold text-gray-800 mb-4">Visualisation du R√©seau</h2>
                        <div class="canvas-container flex-grow">
                            <canvas id="neuralCanvas"></canvas>
                        </div>
                        <div class="mt-4 text-sm text-gray-600 text-center">
                            <p>Le r√©seau s'adapte et √©volue en temps r√©el.</p>
                            <p>Nb. Neurones: <span id="neuronCount" class="font-semibold text-primary">0</span> |
                               Nb. Synapses: <span id="synapseCount" class="font-semibold text-primary">0</span></p>
                            <div class="w-full bg-gray-200 rounded-full h-2.5 mt-2">
                                <div id="replicationProgress" class="progress-bar-fill h-2.5 rounded-full" style="width: 0%"></div>
                            </div>
                            <p class="text-xs text-gray-500 mt-1">Progression de la R√©plication</p>
                        </div>
                    </div>

                    <div class="bg-white p-6 rounded-lg shadow-md flex flex-col">
                        <h2 class="text-2xl font-bold text-gray-800 mb-4">Interface de Communication (IA)</h2>
                        <div id="chatBody" class="flex-grow bg-gray-50 p-4 rounded-lg overflow-y-auto mb-4 custom-scrollbar" style="max-height: 400px; min-height: 200px;">
                            </div>
                        <div class="flex items-center space-x-3">
                            <input type="text" id="chatInput" placeholder="Posez une question √† NeuraX..." class="flex-grow p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary">
                            <button id="sendBtn" class="btn-primary p-3 rounded-lg shadow-md hover:shadow-lg transition duration-300 ease-in-out">
                                <span class="mr-2">üöÄ</span> Envoyer
                            </button>
                            <button id="voiceBtn" class="p-3 bg-gray-200 rounded-lg shadow-md hover:shadow-lg transition duration-300 ease-in-out">
                                <span class="text-lg">üéôÔ∏è</span>
                                <span class="voice-active-dot hidden"></span>
                            </button>
                        </div>
                    </div>
                </section>

                <section id="statsContent" class="content-section">
                    <div class="bg-white p-6 rounded-lg shadow-md mb-8">
                        <h2 class="text-2xl font-bold text-gray-800 mb-4">Statistiques du R√©seau</h2>
                        <div id="statsReport" class="grid grid-cols-1 md:grid-cols-2 gap-4 text-gray-700">
                            <p><strong>Comptage des neurones :</strong> <span id="statNeuronCount">--</span></p>
                            <p><strong>Comptage des connexions :</strong> <span id="statConnectionCount">--</span></p>
                            <p><strong>Neurones actifs :</strong> <span id="statActiveNeurons">--</span></p>
                            <p><strong>√ânergie moyenne :</strong> <span id="statAverageEnergy">--</span></p>
                            <p><strong>Densit√© du r√©seau :</strong> <span id="statNetworkDensity">--</span></p>
                            <p><strong>Motifs reconnus :</strong> <span id="statRecognizedPatterns">--</span></p>
                            <p><strong>Taille de la m√©moire :</strong> <span id="statMemorySize">--</span></p>
                            <p><strong>√âtat du syst√®me :</strong> <span id="statSystemStatus">--</span></p>
                            <p class="md:col-span-2"><strong>Derni√®re mise √† jour :</strong> <span id="statTimestamp">--</span></p>
                        </div>
                        <button id="refreshStatsBtn" class="btn-primary py-2 px-4 rounded-lg mt-6">Rafra√Æchir les Statistiques</button>
                    </div>
                </section>

                <section id="configContent" class="content-section">
                    <div class="bg-white p-6 rounded-lg shadow-md mb-8">
                        <h2 class="text-2xl font-bold text-gray-800 mb-4">Configuration du R√©seau</h2>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div>
                                <label for="configMaxNeurons" class="block text-gray-700 font-semibold mb-2">Nombre Max. de Neurones:</label>
                                <input type="range" id="configMaxNeurons" min="100" max="1000" value="300" class="w-full accent-primary">
                                <p class="text-sm text-gray-600 mt-1">Actuel: <span id="currentMaxNeurons">300</span></p>
                            </div>
                            <div>
                                <label for="configNeuronSpeed" class="block text-gray-700 font-semibold mb-2">Vitesse des Neurones:</label>
                                <input type="range" id="configNeuronSpeed" min="0.1" max="1.0" step="0.1" value="0.3" class="w-full accent-primary">
                                <p class="text-sm text-gray-600 mt-1">Actuel: <span id="currentNeuronSpeed">0.3</span></p>
                            </div>
                            <div>
                                <label for="configGrowthRate" class="block text-gray-700 font-semibold mb-2">Taux de Croissance:</label>
                                <input type="range" id="configGrowthRate" min="1" max="50" value="15" class="w-full accent-primary">
                                <p class="text-sm text-gray-600 mt-1">Actuel: <span id="currentGrowthRate">15</span></p>
                            </div>
                            <div>
                                <label for="configConnectionDistance" class="block text-gray-700 font-semibold mb-2">Distance de Connexion:</label>
                                <input type="range" id="configConnectionDistance" min="100" max="300" value="180" class="w-full accent-primary">
                                <p class="text-sm text-gray-600 mt-1">Actuel: <span id="currentConnectionDistance">180</span></p>
                            </div>
                        </div>
                        <button id="saveConfigBtn" class="btn-primary py-2 px-4 rounded-lg mt-6">Appliquer les Changements</button>
                    </div>
                </section>

                <section id="logsContent" class="content-section">
                    <div class="bg-white p-6 rounded-lg shadow-md mb-8">
                        <h2 class="text-2xl font-bold text-gray-800 mb-4">Journal d'Activit√© du R√©seau</h2>
                        <div id="logBody" class="bg-gray-50 p-4 rounded-lg h-96 overflow-y-auto custom-scrollbar text-sm text-gray-800 font-mono">
                            <p class="text-gray-500"><em>Le journal affichera l'activit√© du r√©seau...</em></p>
                        </div>
                        <button id="clearLogsBtn" class="btn-secondary py-2 px-4 rounded-lg mt-4">Effacer le Journal</button>
                    </div>
                </section>
            </div>
        </div>
    </main>

    <div id="activationModal" class="modal fixed inset-0 flex items-center justify-center hidden">
        <div class="bg-white p-8 rounded-lg shadow-2xl max-w-sm w-full text-center">
            <h3 class="text-xl font-bold mb-4">Activation du Syst√®me NeuraX</h3>
            <p class="mb-4">Choisissez un niveau d'initialisation pour le r√©seau (influence le taux de croissance).</p>
            <input type="range" id="activationLevel" min="1" max="100" value="50" class="w-full accent-primary">
            <p class="text-sm text-gray-600 mt-1">Niveau: <span id="currentActivationLevel">50</span>%</p>

            <div class="flex justify-end space-x-4 mt-6">
                <button id="cancelActivation" class="btn-secondary py-2 px-4 rounded-lg">Annuler</button>
                <button id="confirmActivation" class="btn-primary py-2 px-4 rounded-lg">Confirmer</button>
            </div>
        </div>
    </div>

    <div id="toastContainer" class="toast-container space-y-3"></div>

    <script>
        // Configuration avanc√©e du r√©seau neural
        const neuralConfig = {
            neurons: {
                count: 0,
                maxCount: 300,
                baseSize: 2,
                activeSize: 4,
                colors: ['#3498db', '#9b59b6', '#2ecc71', '#e74c3c', '#f39c12'],
                speed: 0.3,
                connectionDistance: 180,
                connectionOpacity: 0.25,
                growthRate: 15,
                decayRate: 0.05,
                lifespanFactor: 1000,
                mutationRate: 0.02
            },
            animation: {
                pulseFrequency: 2000,
                waveEffect: true,
                glowIntensity: 0.7
            },
            learning: {
                enabled: true,
                adaptiveThreshold: 0.4,
                memoryCapacity: 50,
                patternRecognition: 0.6
            }
        };
        // Classe Neurone am√©lior√©e
        class Neuron {
            constructor(x, y, size, color) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.originalColor = color;
                this.speedX = (Math.random() - 0.5) * neuralConfig.neurons.speed;
                this.speedY = (Math.random() - 0.5) * neuralConfig.neurons.speed;
                this.active = false;
                this.energy = 100;
                this.age = 0;
                this.lifespan = Math.random() * neuralConfig.neurons.lifespanFactor + 5000;
                this.connections = [];
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.lastActivation = 0;
                this.activationHistory = [];
                this.specializationType = Math.floor(Math.random() * 4); // 0: sensory, 1: motor, 2: association, 3: inhibitory
            }
            update(deltaTime, canvas) {
                // Mise √† jour de la position
                this.x += this.speedX;
                this.y += this.speedY;
                // Rebond sur les bords
                if (this.x < 0 || this.x > canvas.width) this.speedX *= -1;
                if (this.y < 0 || this.y > canvas.height) this.speedY *= -1;
                // Vieillissement et √©nergie
                this.age += deltaTime;
                if (this.active) {
                    this.energy -= deltaTime * 0.02;
                } else {
                    this.energy = Math.min(100, this.energy + deltaTime * 0.005);
                }
                // Effet de pulsation
                const pulseSize = Math.sin(this.pulsePhase + performance.now() / neuralConfig.animation.pulseFrequency) * 0.5 + 1;
                this.displaySize = this.active ? this.size * neuralConfig.neurons.activeSize * pulseSize : this.size * pulseSize;
                // Mise √† jour de la couleur bas√©e sur l'√©nergie
                const energyFactor = this.energy / 100;
                const r = parseInt(this.originalColor.slice(1, 3), 16);
                const g = parseInt(this.originalColor.slice(3, 5), 16);
                const b = parseInt(this.originalColor.slice(5, 7), 16);
                this.displayColor = this.active
                    ? `rgba(${r}, ${g}, ${b}, ${energyFactor})`
                    : `rgba(${r}, ${g}, ${b}, ${energyFactor * 0.6})`;
                // Mutation occasionnelle
                if (Math.random() < neuralConfig.neurons.mutationRate * deltaTime / 1000) {
                    this.mutate();
                }
                return this.age < this.lifespan && this.energy > 0;
            }
            activate(duration = 2000) {
                this.active = true;
                this.lastActivation = performance.now();
                this.activationHistory.push(performance.now());
                // Garder seulement les 20 derni√®res activations pour la m√©moire
                if (this.activationHistory.length > 20) {
                    this.activationHistory.shift();
                }
                // D√©sactiver apr√®s une dur√©e
                setTimeout(() => {
                    this.active = false;
                }, duration);
                return this;
            }
            connect(targetNeuron, strength = Math.random()) {
                const connection = {
                    target: targetNeuron,
                    strength: strength,
                    age: 0,
                    active: false,
                    source: this // Add source to connection for easier lookup
                };
                this.connections.push(connection);
                return connection;
            }
            mutate() {
                // Mutation l√©g√®re des propri√©t√©s
                this.speedX += (Math.random() - 0.5) * 0.02;
                this.speedY += (Math.random() - 0.5) * 0.02;
                this.lifespan *= 0.95 + Math.random() * 0.1;
                // Mutation de couleur occasionnelle
                if (Math.random() < 0.2) {
                    const colors = neuralConfig.neurons.colors;
                    this.originalColor = colors[Math.floor(Math.random() * colors.length)];
                }
            }
            draw(ctx) {
                // Dessiner le neurone avec effet de lueur
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.displaySize, 0, Math.PI * 2);
                // Ajouter un effet de lueur si actif
                if (this.active && neuralConfig.animation.glowIntensity > 0) {
                    ctx.shadowBlur = 15 * neuralConfig.animation.glowIntensity;
                    ctx.shadowColor = this.originalColor;
                } else {
                    ctx.shadowBlur = 0;
                }
                ctx.fillStyle = this.displayColor;
                ctx.fill();
                // Marqueur de sp√©cialisation (petit symbole selon le type)
                if (this.active) {
                    ctx.beginPath();
                    const markerSize = this.displaySize * 0.5;
                    ctx.strokeStyle = "#ffffff";
                    ctx.lineWidth = 1;
                    switch(this.specializationType) {
                        case 0: // Sensoriel - cercle
                            ctx.arc(this.x, this.y, markerSize * 0.3, 0, Math.PI * 2);
                            break;
                        case 1: // Moteur - triangle
                            ctx.moveTo(this.x, this.y - markerSize * 0.3);
                            ctx.lineTo(this.x + markerSize * 0.3, this.y + markerSize * 0.3);
                            ctx.lineTo(this.x - markerSize * 0.3, this.y + markerSize * 0.3);
                            break;
                        case 2: // Association - carr√©
                            ctx.rect(this.x - markerSize * 0.2, this.y - markerSize * 0.2, markerSize * 0.4, markerSize * 0.4);
                            break;
                        case 3: // Inhibiteur - croix
                            ctx.moveTo(this.x - markerSize * 0.2, this.y - markerSize * 0.2);
                            ctx.lineTo(this.x + markerSize * 0.2, this.y + markerSize * 0.2);
                            ctx.moveTo(this.x + markerSize * 0.2, this.y - markerSize * 0.2);
                            ctx.lineTo(this.x - markerSize * 0.2, this.y + markerSize * 0.2);
                            break;
                    }
                    ctx.stroke();
                }
            }
        }
        // Classe pour le r√©seau neuronal
        class NeuralNetwork {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.neurons = [];
                this.connections = [];
                this.isActive = false;
                this.lastUpdate = performance.now();
                this.stats = {
                    neuronCount: 0,
                    connectionCount: 0,
                    activeNeurons: 0,
                    averageEnergy: 0,
                    cycles: 0,
                    patternMatches: 0
                };
                this.memoryPatterns = [];
                this.eventListeners = {};
                // Bind canvas resize
                window.addEventListener('resize', this.resizeCanvas.bind(this));
                this.resizeCanvas();
            }
            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
            }
            initialize(initialNeurons = 50) {
                this.resizeCanvas(); // Ensure canvas is sized correctly on init
                // Cr√©er les premiers neurones
                for (let i = 0; i < initialNeurons; i++) {
                    this.createNeuron();
                }
                // D√©marrer la boucle d'animation
                this.lastUpdate = performance.now();
                this.animate();
                return this;
            }
            createNeuron(x, y) {
                // Position al√©atoire si non sp√©cifi√©e
                x = x || Math.random() * this.canvas.width;
                y = y || Math.random() * this.canvas.height;
                const size = neuralConfig.neurons.baseSize;
                const colorIndex = Math.floor(Math.random() * neuralConfig.neurons.colors.length);
                const color = neuralConfig.neurons.colors[colorIndex];
                const neuron = new Neuron(x, y, size, color);
                this.neurons.push(neuron);
                // Cr√©er des connexions avec les neurones existants
                const nearbyNeurons = this.findNearbyNeurons(neuron, neuralConfig.neurons.connectionDistance);
                for (const targetNeuron of nearbyNeurons) {
                    if (Math.random() < 0.3) { // 30% de chance de connexion
                        const connection = neuron.connect(targetNeuron);
                        this.connections.push(connection);
                    }
                }
                this.stats.neuronCount = this.neurons.length;
                this.trigger('neuronCreated', neuron);
                return neuron;
            }
            findNearbyNeurons(neuron, maxDistance) {
                return this.neurons.filter(n => {
                    if (n === neuron) return false;
                    const dx = n.x - neuron.x;
                    const dy = n.y - neuron.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance < maxDistance;
                });
            }
            animate() {
                // Calculer le temps √©coul√© depuis la derni√®re mise √† jour
                const now = performance.now();
                const deltaTime = now - this.lastUpdate;
                this.lastUpdate = now;
                // Effacer le canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                // Mettre √† jour les neurones et les connexions
                this.updateNetwork(deltaTime);
                // Croissance automatique si actif
                if (this.isActive && this.neurons.length < neuralConfig.neurons.maxCount) {
                    if (Math.random() < neuralConfig.neurons.growthRate * deltaTime / 5000) {
                        this.createNeuron();
                    }
                }
                // Reconna√Ætre des motifs
                this.recognizePatterns();
                // Mettre √† jour les statistiques
                this.updateStats();
                // Continuer l'animation
                requestAnimationFrame(() => this.animate());
            }
            updateNetwork(deltaTime) {
                // Mettre √† jour et dessiner les connexions
                this.drawConnections();
                // Mettre √† jour et dessiner les neurones, supprimer les morts
                let activeCount = 0;
                let totalEnergy = 0;
                const deadNeurons = [];
                for (let i = 0; i < this.neurons.length; i++) {
                    const neuron = this.neurons[i];
                    const isAlive = neuron.update(deltaTime, this.canvas); // Pass canvas for bounds check
                    if (!isAlive) {
                        deadNeurons.push(i);
                    } else {
                        neuron.draw(this.ctx);
                        // Compter les neurones actifs et l'√©nergie totale
                        if (neuron.active) activeCount++;
                        totalEnergy += neuron.energy;
                        // Propagation d'activation entre neurones connect√©s
                        if (neuron.active && Math.random() < 0.1) {
                            this.propagateActivation(neuron);
                        }
                    }
                }
                // Supprimer les neurones morts (en partant de la fin pour ne pas perturber les indices)
                for (let i = deadNeurons.length - 1; i >= 0; i--) {
                    const deadNeuron = this.neurons[deadNeurons[i]];
                    this.neurons.splice(deadNeurons[i], 1);
                    // Remove connections associated with this dead neuron
                    this.connections = this.connections.filter(conn => conn.source !== deadNeuron && conn.target !== deadNeuron);
                }
                if (deadNeurons.length > 0) {
                    this.trigger('neuronsRemoved', deadNeurons.length);
                }
                // Mettre √† jour les statistiques
                this.stats.activeNeurons = activeCount;
                this.stats.averageEnergy = this.neurons.length > 0 ? totalEnergy / this.neurons.length : 0;
                this.stats.cycles++;
            }
            drawConnections() {
                // Mise √† jour des connexions et dessin
                const deadConnections = [];
                for (let i = 0; i < this.connections.length; i++) {
                    const connection = this.connections[i];
                    // V√©rifier si les neurones existent toujours
                    const source = connection.source;
                    const target = connection.target;
                    // Check if both source and target neurons still exist in the network's neurons array
                    if (!this.neurons.includes(source) || !this.neurons.includes(target)) {
                        deadConnections.push(i);
                        continue;
                    }
                    // Calculer la distance
                    const dx = target.x - source.x;
                    const dy = target.y - source.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    // Dessiner seulement si assez proche
                    if (distance < neuralConfig.neurons.connectionDistance) {
                        // Calculer l'opacit√© bas√©e sur la distance et l'√©nergie
                        const distanceFactor = 1 - distance / neuralConfig.neurons.connectionDistance;
                        const energyFactor = (source.energy + target.energy) / 200;
                        const opacity = distanceFactor * neuralConfig.neurons.connectionOpacity * energyFactor;
                        // D√©terminer la couleur
                        let color;
                        if (source.active && target.active) {
                            // Connexion tr√®s active
                            color = `rgba(255, 255, 255, ${opacity * 1.5})`;
                        } else if (source.active || target.active) {
                            // Connexion semi-active
                            const r = parseInt(source.originalColor.slice(1, 3), 16);
                            const g = parseInt(source.originalColor.slice(3, 5), 16);
                            const b = parseInt(source.originalColor.slice(5, 7), 16);
                            color = `rgba(${r}, ${g}, ${b}, ${opacity * 1.2})`;
                        } else {
                            // Connexion inactive
                            color = `rgba(52, 152, 219, ${opacity})`;
                        }
                        // Dessiner la connexion
                        this.ctx.beginPath();
                        this.ctx.moveTo(source.x, source.y);
                        this.ctx.lineTo(target.x, target.y);
                        this.ctx.strokeStyle = color;
                        this.ctx.lineWidth = source.active || target.active ? 1.5 : 1;
                        // Effet de pulsation sur les connexions actives
                        if ((source.active || target.active) && neuralConfig.animation.waveEffect) {
                            this.ctx.setLineDash([5, 5]);
                            this.ctx.lineDashOffset = -performance.now() / 100;
                        } else {
                            this.ctx.setLineDash([]);
                        }
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);
                    } else {
                        // Connexion trop √©loign√©e
                        deadConnections.push(i);
                    }
                }
                // Supprimer les connexions mortes
                for (let i = deadConnections.length - 1; i >= 0; i--) {
                    this.connections.splice(deadConnections[i], 1);
                }
                this.stats.connectionCount = this.connections.length;
            }
            propagateActivation(sourceNeuron) {
                // Propager l'activation aux neurones connect√©s
                for (const connection of sourceNeuron.connections) {
                    const targetNeuron = connection.target;
                    // Probabilit√© d'activation bas√©e sur la force de la connexion
                    if (Math.random() < connection.strength * 0.7 && !targetNeuron.active) { // Prevent reactivating already active neurons
                        targetNeuron.activate(1000 + Math.random() * 1000);
                        // Renforcer la connexion (apprentissage)
                        if (neuralConfig.learning.enabled) {
                            connection.strength = Math.min(1, connection.strength + 0.01);
                        }
                    }
                }
            }
            activateRandomNeurons(count = 3) {
                // Activer quelques neurones al√©atoires pour stimuler le r√©seau
                if (this.neurons.length === 0) return;
                for (let i = 0; i < count; i++) {
                    const index = Math.floor(Math.random() * this.neurons.length);
                    if (this.neurons[index]) {
                        this.neurons[index].activate(2000 + Math.random() * 3000);
                    }
                }
            }
            activateByPattern(pattern) {
                // Activation bas√©e sur un motif sp√©cifique (ex: entr√©e utilisateur)
                if (this.neurons.length === 0) return;
                // Convertir le pattern en une empreinte d'activation
                const patternHash = this.hashPattern(pattern);
                // S√©lectionner les neurones √† activer bas√©s sur le hash
                const neuronIndices = [];
                // Simple mapping: use character codes to pick neurons
                for (let i = 0; i < pattern.length; i++) {
                    const charCode = pattern.charCodeAt(i);
                    const index = charCode % this.neurons.length; // Ensures index is within bounds
                    if (!neuronIndices.includes(index)) { // Avoid duplicate activations for same pattern char
                         neuronIndices.push(index);
                    }
                }
                // Activer les neurones s√©lectionn√©s
                for (const index of neuronIndices) {
                    if (this.neurons[index]) { // Ensure neuron still exists
                        this.neurons[index].activate(3000);
                    }
                }
                // M√©moriser le motif
                if (neuralConfig.learning.enabled) {
                    const currentPattern = {
                        pattern: patternHash,
                        originalPattern: pattern, // Store original for potential debug/recall
                        neurons: [...new Set(neuronIndices)], // Store unique indices
                        timestamp: Date.now()
                    };
                    // Check if a similar pattern already exists to avoid exact duplicates
                    const existing = this.memoryPatterns.find(mp => mp.pattern === currentPattern.pattern);
                    if (!existing) {
                        this.memoryPatterns.push(currentPattern);
                        // Limiter la taille de la m√©moire
                        if (this.memoryPatterns.length > neuralConfig.learning.memoryCapacity) {
                            this.memoryPatterns.shift();
                        }
                        this.trigger('patternMemorized', currentPattern);
                    }
                }
                this.trigger('patternActivated', pattern);
            }
            recognizePatterns() {
                // Analyser l'√©tat actuel pour reconna√Ætre des motifs connus
                if (!neuralConfig.learning.enabled || this.neurons.length === 0) return;
                // Cr√©er une empreinte de l'√©tat actuel des neurones
                const activeNeuronIndices = [];
                for (let i = 0; i < this.neurons.length; i++) {
                    if (this.neurons[i].active) {
                        activeNeuronIndices.push(i);
                    }
                }
                if (activeNeuronIndices.length < 3) return; // Pas assez de neurones actifs pour une reconnaissance significative
                // Comparer avec les motifs m√©moris√©s
                for (const pattern of this.memoryPatterns) {
                    let matches = 0;
                    for (const activeIndex of activeNeuronIndices) {
                        if (pattern.neurons.includes(activeIndex)) {
                            matches++;
                        }
                    }
                    // Calculer le score de correspondance
                    const matchScore = matches / Math.max(pattern.neurons.length, activeNeuronIndices.length);
                    // If enough similar, it's a match
                    if (matchScore > neuralConfig.learning.patternRecognition) {
                        this.stats.patternMatches++;
                        this.trigger('patternRecognized', pattern);
                        // Strengthen this pattern by activating associated neurons
                        for (const neuronIndex of pattern.neurons) {
                            if (this.neurons[neuronIndex]) { // Ensure neuron still exists
                                this.neurons[neuronIndex].activate(2000);
                            }
                        }
                        return pattern; // Return the recognized pattern
                    }
                }
                return null; // No pattern recognized
            }
            hashPattern(input) {
                // Simple function to create a hash of the pattern
                let hash = 0;
                for (let i = 0; i < input.length; i++) {
                    const char = input.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                return hash.toString(); // Return as string to avoid numerical issues with large hashes
            }
            updateStats() {
                // Mettre √† jour les statistiques de r√©seau
                document.getElementById('neuronCount').textContent = this.stats.neuronCount;
                document.getElementById('synapseCount').textContent = this.stats.connectionCount;
                // Mettre √† jour la progression de r√©plication
                const progress = Math.min(100, Math.floor((this.stats.neuronCount / neuralConfig.neurons.maxCount) * 100));
                document.getElementById('replicationProgress').style.width = `${progress}%`;
            }
            activate() {
                // Activer le syst√®me neural
                if(this.isActive) return; // Prevent multiple activations
                this.isActive = true;
                this.activateRandomNeurons(5);
                // D√©marrer l'activation cyclique
                this.activationInterval = setInterval(() => {
                    this.activateRandomNeurons(2);
                }, 2000);
                this.trigger('systemActivated');
                return this;
            }
            deactivate() {
                // D√©sactiver le syst√®me neural
                if(!this.isActive) return; // Prevent multiple deactivations
                this.isActive = false;
                clearInterval(this.activationInterval);
                this.trigger('systemDeactivated');
                return this;
            }
            // Syst√®me d'√©v√©nements simple
            on(eventName, callback) {
                if (!this.eventListeners[eventName]) {
                    this.eventListeners[eventName] = [];
                }
                this.eventListeners[eventName].push(callback);
                return this;
            }
            trigger(eventName, data) {
                if (this.eventListeners[eventName]) {
                    for (const callback of this.eventListeners[eventName]) {
                        callback(data);
                    }
                }
                return this;
            }
            // Fonctions d'analyse
            generateReport() {
                return {
                    neuronCount: this.stats.neuronCount,
                    connectionCount: this.stats.connectionCount,
                    activeNeurons: this.stats.activeNeurons,
                    averageEnergy: this.stats.averageEnergy.toFixed(2),
                    networkDensity: this.stats.neuronCount > 1 ? (this.stats.connectionCount / (this.stats.neuronCount * (this.stats.neuronCount - 1) / 2)).toFixed(4) : 0,
                    recognizedPatterns: this.stats.patternMatches,
                    memorySize: this.memoryPatterns.length,
                    systemStatus: this.isActive ? 'Actif' : 'Inactif',
                    timestamp: new Date().toLocaleString()
                };
            }
            // Sauvegarde et chargement
            exportState() {
                // Version simplifi√©e - sauvegarde uniquement les configurations et statistiques
                return {
                    config: neuralConfig,
                    stats: this.stats,
                    memoryPatterns: this.memoryPatterns.map(p => ({
                        pattern: p.pattern,
                        neurons: p.neurons,
                        timestamp: p.timestamp,
                        originalPattern: p.originalPattern // Also store original for display
                    })),
                    timestamp: Date.now()
                };
            }
            importState(state) {
                // Importer seulement ce qui est s√ªr
                if (state.config) {
                    // Mise √† jour de la configuration en pr√©servant la structure
                    Object.keys(state.config).forEach(section => {
                        if (neuralConfig[section]) {
                            Object.keys(state.config[section]).forEach(param => {
                                if (neuralConfig[section][param] !== undefined) {
                                    neuralConfig[section][param] = state.config[section][param];
                                }
                            });
                        }
                    });
                }
                if (state.memoryPatterns) {
                    // Filtrer uniquement les motifs valides
                    this.memoryPatterns = state.memoryPatterns.filter(p =>
                        p.pattern && Array.isArray(p.neurons) && p.timestamp
                    ).slice(0, neuralConfig.learning.memoryCapacity);
                }
                // Note: Re-creating neurons from state requires more complex serialization,
                // so for this example, we only import config and patterns.
                return this;
            }
        }
        // Fonctions utilitaires pour l'interface utilisateur
        const NeuraXUI = {
            neuralNetwork: null,
            voiceRecognitionActive: false,
            // Initialisation de l'interface
            initialize(neuralNetworkInstance) {
                this.neuralNetwork = neuralNetworkInstance;

                // Control System Buttons
                document.getElementById('startBtn').addEventListener('click', () => {
                    document.getElementById('activationModal').style.display = 'flex';
                    document.getElementById('currentActivationLevel').textContent = document.getElementById('activationLevel').value;
                });
                document.getElementById('deactivateBtn').addEventListener('click', () => {
                    this.deactivateSystem();
                });

                // Activation Modal Buttons
                document.getElementById('closeActivationModal').addEventListener('click', () => {
                    document.getElementById('activationModal').style.display = 'none';
                });
                document.getElementById('cancelActivation').addEventListener('click', () => {
                    document.getElementById('activationModal').style.display = 'none';
                });
                document.getElementById('confirmActivation').addEventListener('click', () => {
                    document.getElementById('activationModal').style.display = 'none';
                    this.activateSystem();
                });
                document.getElementById('activationLevel').addEventListener('input', (e) => {
                    document.getElementById('currentActivationLevel').textContent = e.target.value;
                });

                // Chat Interface
                const chatInput = document.getElementById('chatInput');
                const sendBtn = document.getElementById('sendBtn');
                chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.sendChatMessage();
                    }
                });
                sendBtn.addEventListener('click', () => {
                    this.sendChatMessage();
                });
                document.getElementById('voiceBtn').addEventListener('click', (e) => {
                    this.toggleVoiceRecognition(e.currentTarget);
                });

                // Sidebar & Navigation
                document.getElementById('menuToggle')?.addEventListener('click', () => {
                    document.getElementById('sidebar').classList.toggle('open');
                });
                document.addEventListener('click', (event) => {
                    const sidebar = document.getElementById('sidebar');
                    const menuToggle = document.getElementById('menuToggle');
                    // Close sidebar if click outside on mobile
                    if (window.innerWidth < 768 && sidebar.classList.contains('open') && !sidebar.contains(event.target) && !menuToggle.contains(event.target)) {
                        sidebar.classList.remove('open');
                    }
                });

                const navItems = document.querySelectorAll('.nav-item');
                navItems.forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.preventDefault(); // Prevent default hash navigation
                        const targetContentId = item.dataset.targetContent;
                        this.showSection(targetContentId);

                        navItems.forEach(navItem => navItem.classList.remove('active'));
                        item.classList.add('active');

                        this.showToast(`Navigation vers ${item.querySelector('span:last-child').textContent.trim()}`, 'success');

                        // For dynamic content sections
                        if (targetContentId === 'statsContent') {
                            this.updateStatsDisplay();
                        }
                    });
                });

                // Configuration Section Handlers
                document.getElementById('configMaxNeurons').addEventListener('input', (e) => {
                    document.getElementById('currentMaxNeurons').textContent = e.target.value;
                });
                document.getElementById('configNeuronSpeed').addEventListener('input', (e) => {
                    document.getElementById('currentNeuronSpeed').textContent = e.target.value;
                });
                document.getElementById('configGrowthRate').addEventListener('input', (e) => {
                    document.getElementById('currentGrowthRate').textContent = e.target.value;
                });
                document.getElementById('configConnectionDistance').addEventListener('input', (e) => {
                    document.getElementById('currentConnectionDistance').textContent = e.target.value;
                });

                document.getElementById('saveConfigBtn').addEventListener('click', () => {
                    this.applyConfigChanges();
                });

                // Stats Refresh Button
                document.getElementById('refreshStatsBtn').addEventListener('click', () => {
                    this.updateStatsDisplay();
                    this.showToast('Statistiques rafra√Æchies', 'info');
                });

                // Clear Logs Button
                document.getElementById('clearLogsBtn').addEventListener('click', () => {
                    document.getElementById('logBody').innerHTML = '<p class="text-gray-500"><em>Le journal affichera l\'activit√© du r√©seau...</em></p>';
                    this.showToast('Journal effac√©', 'info');
                });

                // Initial chat message
                this.addChatMessage('Bonjour ! Je suis NeuraX. Comment puis-je vous aider aujourd\'hui ?', 'ai');

                // Listen for network events to update logs
                this.neuralNetwork.on('systemActivated', () => {
                    document.getElementById('startBtn').classList.add('hidden');
                    document.getElementById('deactivateBtn').classList.remove('hidden');
                    this.addChatMessage('Syst√®me NeuraX activ√©. Initialisation du r√©seau en cours...', 'ai');
                    this.addLogEntry('Syst√®me NeuraX activ√©.');
                });
                this.neuralNetwork.on('systemDeactivated', () => {
                    document.getElementById('deactivateBtn').classList.add('hidden');
                    document.getElementById('startBtn').classList.remove('hidden');
                    this.addChatMessage('Syst√®me NeuraX d√©sactiv√©. Mise en veille des processus.', 'ai');
                    this.addLogEntry('Syst√®me NeuraX d√©sactiv√©.');
                });
                this.neuralNetwork.on('neuronCreated', (neuron) => {
                    this.addLogEntry(`Nouveau neurone cr√©√© √† (${neuron.x.toFixed(0)}, ${neuron.y.toFixed(0)}).`);
                });
                this.neuralNetwork.on('neuronsRemoved', (count) => {
                    this.addLogEntry(`${count} neurone(s) supprim√©(s) (vieillissement/√©nergie).`);
                });
                this.neuralNetwork.on('patternRecognized', (patternData) => {
                    this.addChatMessage(`NeuraX a reconnu un motif ! "${patternData.originalPattern || patternData.pattern}".`, 'ai');
                    this.addLogEntry(`Motif "${patternData.originalPattern || patternData.pattern}" reconnu par le r√©seau.`);
                });
                this.neuralNetwork.on('patternMemorized', (patternData) => {
                    this.addLogEntry(`Nouveau motif m√©moris√©: "${patternData.originalPattern || patternData.pattern}".`);
                });

                // Initialize first section view
                this.showSection('overviewContent');
                this.updateConfigDisplay(); // Load current config values into UI
            },
            // Show selected content section
            showSection(sectionId) {
                document.querySelectorAll('.content-section').forEach(section => {
                    section.classList.remove('active');
                });
                document.getElementById(sectionId).classList.add('active');
            },
            // System Activation / Deactivation
            activateSystem() {
                const activationLevel = parseInt(document.getElementById('activationLevel').value, 10);
                if (this.neuralNetwork) {
                    this.neuralNetwork.activate();
                    neuralConfig.neurons.growthRate = 5 + (activationLevel / 10); // Adjust growth based on level
                    this.showToast(`NeuraX-Ultime activ√© avec un niveau d'initialisation de ${activationLevel}%`, 'success');
                } else {
                    this.showToast('Erreur: R√©seau neural non initialis√©', 'error');
                }
            },
            deactivateSystem() {
                if (this.neuralNetwork) {
                    this.neuralNetwork.deactivate();
                    this.showToast('NeuraX-Ultime d√©sactiv√©.', 'info');
                }
            },
            // Chat Message Handling
            sendChatMessage() {
                const chatInput = document.getElementById('chatInput');
                const message = chatInput.value.trim();
                if (!message) return;

                this.addChatMessage(message, 'user');
                chatInput.value = '';

                if (this.neuralNetwork) {
                    this.neuralNetwork.activateByPattern(message);
                }

                const chatBody = document.getElementById('chatBody');
                const thinkingIndicator = document.createElement('div');
                thinkingIndicator.className = 'thinking-indicator';
                thinkingIndicator.innerHTML = `
                    <div class="thinking-dot"></div>
                    <div class="thinking-dot"></div>
                    <div class="thinking-dot"></div>
                `;
                chatBody.appendChild(thinkingIndicator);
                chatBody.scrollTop = chatBody.scrollHeight;

                setTimeout(() => {
                    thinkingIndicator.remove();
                    this.generateResponse(message);
                }, 1500 + Math.random() * 1000);
            },
            addChatMessage(text, type) {
                const chatBody = document.getElementById('chatBody');
                const messageEl = document.createElement('div');
                messageEl.className = `chat-message p-3 rounded-lg mb-2 max-w-xs md:max-w-md shadow-sm ${type}`;
                messageEl.textContent = text;
                chatBody.appendChild(messageEl);
                chatBody.scrollTop = chatBody.scrollHeight;
            },
            addLogEntry(text) {
                const logBody = document.getElementById('logBody');
                const logEntry = document.createElement('p');
                const timestamp = new Date().toLocaleTimeString();
                logEntry.innerHTML = `<span class="text-gray-500">[${timestamp}]</span> ${text}`;
                logBody.appendChild(logEntry);
                logBody.scrollTop = logBody.scrollHeight;
            },
            // AI Response Logic
            generateResponse(userMessage) {
                const report = this.neuralNetwork.generateReport();
                let response = "";

                const lowerCaseMessage = userMessage.toLowerCase();

                if (lowerCaseMessage.includes("bonjour") || lowerCaseMessage.includes("salut")) {
                    response = "Bonjour ! Comment puis-je vous assister concernant le r√©seau NeuraX ?";
                } else if (lowerCaseMessage.includes("comment vas-tu") || lowerCaseMessage.includes("√ßa va")) {
                    response = "En tant que syst√®me num√©rique, je n'ai pas de sensations, mais tous mes modules fonctionnent de mani√®re optimale. Merci de demander !";
                } else if (lowerCaseMessage.includes("combien de neurones") || lowerCaseMessage.includes("nombre de neurones")) {
                    response = `Actuellement, le r√©seau compte ${report.neuronCount} neurones.`;
                } else if (lowerCaseMessage.includes("combien de synapses") || lowerCaseMessage.includes("nombre de connexions")) {
                    response = `Il y a ${report.connectionCount} synapses actives dans le r√©seau.`;
                } else if (lowerCaseMessage.includes("√©tat du syst√®me") || lowerCaseMessage.includes("actif") || lowerCaseMessage.includes("statut")) {
                    response = `Le syst√®me est actuellement ${report.systemStatus}. Il y a ${report.activeNeurons} neurones actifs en ce moment.`;
                } else if (lowerCaseMessage.includes("capacit√© de m√©moire") || lowerCaseMessage.includes("motifs m√©moris√©s")) {
                     response = `La capacit√© de m√©moire actuelle pour les motifs est de ${neuralConfig.learning.memoryCapacity} emplacements, et nous avons m√©moris√© ${report.memorySize} motifs.`;
                } else if (lowerCaseMessage.includes("que peux-tu faire") || lowerCaseMessage.includes("fonctionnalit√©s")) {
                    response = "Je simule un r√©seau neuronal avec des capacit√©s de croissance, d'activation, de propagation et d'apprentissage de motifs. Je peux aussi vous fournir des statistiques en temps r√©el et interagir via ce chat.";
                } else if (lowerCaseMessage.includes("merci") || lowerCaseMessage.includes("super") || lowerCaseMessage.includes("cool")) {
                    response = "De rien ! N'h√©sitez pas si vous avez d'autres questions ou si vous souhaitez explorer le r√©seau.";
                } else if (lowerCaseMessage.includes("rapport") || lowerCaseMessage.includes("analyse")) {
                    this.showSection('statsContent'); // Automatically navigate to stats section
                    this.updateStatsDisplay();
                    response = `J'ai g√©n√©r√© un rapport d'√©tat pour vous. Veuillez consulter la section "Statistiques".`;
                } else if (lowerCaseMessage.includes("config") || lowerCaseMessage.includes("param√®tres")) {
                    this.showSection('configContent'); // Automatically navigate to config section
                    response = `Vous pouvez ajuster les param√®tres du r√©seau dans la section "Configuration".`;
                }
                 else {
                    const recognizedPattern = this.neuralNetwork.recognizePatterns();
                    if (recognizedPattern) {
                        response = `Je d√©tecte un motif li√© √† "${recognizedPattern.originalPattern || 'un concept abstrait'}". Cela semble important pour mon r√©seau.`;
                    } else if (report.activeNeurons > 0 && Math.random() < 0.5) { // Add some variability
                         response = `Je traite votre requ√™te... L'activit√© neurale est de ${report.activeNeurons} neurones actifs, et l'√©nergie moyenne est de ${report.averageEnergy}%.`;
                    } else {
                        response = "Hmm, je n'ai pas de r√©ponse sp√©cifique pour cela pour le moment. Mon r√©seau est en cours d'analyse ou je ne suis pas encore entra√Æn√© sur ce type de requ√™te.";
                    }
                }
                this.addChatMessage(response, 'ai');
            },
            // Voice Recognition Toggle
            toggleVoiceRecognition(buttonElement) {
                const dot = buttonElement.querySelector('.voice-active-dot');
                if (!('webkitSpeechRecognition' in window)) {
                    this.showToast('La reconnaissance vocale n\'est pas support√©e par votre navigateur.', 'error');
                    return;
                }

                if (this.voiceRecognitionActive) {
                    this.voiceRecognitionActive = false;
                    dot.classList.add('hidden');
                    this.recognition.stop(); // Stop actual recognition
                    this.showToast('Reconnaissance vocale d√©sactiv√©e.', 'info');
                } else {
                    this.voiceRecognitionActive = true;
                    dot.classList.remove('hidden');
                    this.showToast('Reconnaissance vocale activ√©e. Parlez maintenant...', 'success');

                    this.recognition = new webkitSpeechRecognition();
                    this.recognition.lang = 'fr-FR';
                    this.recognition.interimResults = false;
                    this.recognition.maxAlternatives = 1;

                    this.recognition.onresult = (event) => {
                        const transcript = event.results[0][0].transcript;
                        document.getElementById('chatInput').value = transcript;
                        this.sendChatMessage();
                        this.toggleVoiceRecognition(buttonElement); // Auto-stop after result
                    };

                    this.recognition.onerror = (event) => {
                        this.showToast(`Erreur de reconnaissance vocale: ${event.error}`, 'error');
                        this.toggleVoiceRecognition(buttonElement); // Ensure UI updates on error
                    };

                    this.recognition.onend = () => {
                        if (this.voiceRecognitionActive) { // Only if not manually stopped, means an auto-stop
                            this.toggleVoiceRecognition(buttonElement);
                        }
                    };
                    this.recognition.start();
                }
            },
            // Toast Notifications
            showToast(message, type = 'info', duration = 3000) {
                const toastContainer = document.getElementById('toastContainer');
                const toast = document.createElement('div');
                toast.className = `toast p-3 rounded-lg shadow-md mb-3 flex items-center space-x-2 ${type}`;
                toast.innerHTML = `
                    <span class="text-xl">
                        ${type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : '‚ÑπÔ∏è'}
                    </span>
                    <span>${message}</span>
                `;
                toastContainer.appendChild(toast);

                setTimeout(() => {
                    toast.remove();
                }, duration);
            },
            // Update Stats Display
            updateStatsDisplay() {
                const report = this.neuralNetwork.generateReport();
                document.getElementById('statNeuronCount').textContent = report.neuronCount;
                document.getElementById('statConnectionCount').textContent = report.connectionCount;
                document.getElementById('statActiveNeurons').textContent = report.activeNeurons;
                document.getElementById('statAverageEnergy').textContent = `${report.averageEnergy}%`;
                document.getElementById('statNetworkDensity').textContent = report.networkDensity;
                document.getElementById('statRecognizedPatterns').textContent = report.recognizedPatterns;
                document.getElementById('statMemorySize').textContent = `${report.memorySize} / ${neuralConfig.learning.memoryCapacity}`;
                document.getElementById('statSystemStatus').textContent = report.systemStatus;
                document.getElementById('statTimestamp').textContent = report.timestamp;
            },
            // Update Config Display and Apply Changes
            updateConfigDisplay() {
                document.getElementById('configMaxNeurons').value = neuralConfig.neurons.maxCount;
                document.getElementById('currentMaxNeurons').textContent = neuralConfig.neurons.maxCount;

                document.getElementById('configNeuronSpeed').value = neuralConfig.neurons.speed;
                document.getElementById('currentNeuronSpeed').textContent = neuralConfig.neurons.speed;

                document.getElementById('configGrowthRate').value = neuralConfig.neurons.growthRate;
                document.getElementById('currentGrowthRate').textContent = neuralConfig.neurons.growthRate;

                document.getElementById('configConnectionDistance').value = neuralConfig.neurons.connectionDistance;
                document.getElementById('currentConnectionDistance').textContent = neuralConfig.neurons.connectionDistance;
            },
            applyConfigChanges() {
                neuralConfig.neurons.maxCount = parseInt(document.getElementById('configMaxNeurons').value, 10);
                neuralConfig.neurons.speed = parseFloat(document.getElementById('configNeuronSpeed').value);
                neuralConfig.neurons.growthRate = parseInt(document.getElementById('configGrowthRate').value, 10);
                neuralConfig.neurons.connectionDistance = parseInt(document.getElementById('configConnectionDistance').value, 10);
                this.showToast('Configuration appliqu√©e ! Les changements prendront effet progressivement.', 'success');
                // Re-render config display to confirm
                this.updateConfigDisplay();
            }
        };

        // Main execution when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('neuralCanvas');
            window.neuralNetwork = new NeuralNetwork(canvas);
            window.neuralNetwork.initialize(50); // Start with 50 neurons

            NeuraXUI.initialize(window.neuralNetwork);
        });
    </script>
</body>
</html><!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuraX-Ultime : Simulation Neuronale</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        /* Custom styles for the selected vibrant palette - "Energetic & Playful" (Yellow, Teal, Purple) */
        :root {
            --color-primary: #00CED1; /* Teal */
            --color-secondary: #FFD700; /* Yellow */
            --color-accent: #8A2BE2; /* Purple */
            --color-text-dark: #333;
            --color-text-light: #fefefe;
            --color-bg-light: #f8f8f8;
            --color-bg-dark: #2d3748; /* For darker elements like sidebar */
        }
        body {
            background-color: var(--color-bg-light);
            color: var(--color-text-dark);
        }
        .header-bg {
            background-color: var(--color-primary);
        }
        .sidebar {
            background-color: var(--color-bg-dark); /* Darker background for sidebar */
            width: 250px;
            transform: translateX(-100%);
            transition: transform 0.3s ease-in-out;
            z-index: 100;
        }
        .sidebar.open {
            transform: translateX(0);
        }
        @media (min-width: 768px) {
            .sidebar {
                transform: translateX(0);
            }
            .main-content-area {
                margin-left: 250px; /* Adjust main content to sidebar width */
            }
        }

        .nav-item {
            color: var(--color-text-light);
            transition: background-color 0.2s ease;
        }
        .nav-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .nav-item.active {
            background-color: var(--color-accent);
            font-weight: bold;
        }
        .btn-primary {
            background-color: var(--color-primary);
            color: var(--color-text-light);
        }
        .btn-primary:hover {
            background-color: #00BFFF; /* A slightly lighter teal */
        }
        .btn-secondary {
            background-color: #e2e8f0; /* Gray-200 */
            color: var(--color-text-dark);
        }
        .btn-secondary:hover {
            background-color: #cbd5e0; /* Gray-300 */
        }
        .progress-bar-fill {
            background-color: var(--color-accent);
        }
        .modal {
            background-color: rgba(0, 0, 0, 0.7);
        }
        .toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 1000;
        }
        .toast {
            background-color: var(--color-primary);
            color: var(--color-text-light);
        }
        .toast.success {
            background-color: #2ecc71; /* Green */
        }
        .toast.error {
            background-color: #e74c3c; /* Red */
        }
        .chat-message.user {
            background-color: var(--color-accent);
            color: var(--color-text-light);
            align-self: flex-end;
            border-bottom-right-radius: 0;
        }
        .chat-message.ai {
            background-color: var(--color-secondary);
            color: var(--color-text-dark);
            align-self: flex-start;
            border-bottom-left-radius: 0;
        }
        .thinking-indicator {
            display: flex;
            justify-content: flex-start;
            margin-bottom: 0.5rem;
        }
        .thinking-dot {
            width: 8px;
            height: 8px;
            background-color: #ccc;
            border-radius: 50%;
            margin: 0 2px;
            animation: bounce 1.4s infinite ease-in-out both;
        }
        .thinking-dot:nth-child(1) { animation-delay: -0.32s; }
        .thinking-dot:nth-child(2) { animation-delay: -0.16s; }
        .thinking-dot:nth-child(3) { animation-delay: 0s; }
        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }
        .voice-active-dot {
            width: 10px;
            height: 10px;
            background-color: #2ecc71; /* Green for active */
            border-radius: 50%;
            display: inline-block;
            animation: pulse-voice 1.5s infinite ease-in-out;
        }
        @keyframes pulse-voice {
            0% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(46, 204, 113, 0); }
            100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); }
        }
        /* Canvas container styling for responsiveness */
        .canvas-container {
            position: relative;
            width: 100%;
            padding-top: 56.25%; /* 16:9 Aspect Ratio (height / width * 100%) */
            overflow: hidden;
            background-color: #f8f8f8;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 800px; /* Max width for readability on large screens */
            margin-left: auto;
            margin-right: auto;
        }
        .canvas-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>
<body class="flex flex-col md:flex-row min-h-screen">
    <aside id="sidebar" class="sidebar fixed inset-y-0 left-0 w-64 p-6 md:relative md:transform-none shadow-lg md:shadow-none transition-transform duration-300 ease-in-out flex flex-col items-center z-50">
        <div class="mb-8 text-center">
            <h2 class="text-3xl font-bold text-white mb-2">NeuraX-Ultime</h2>
            <p class="text-sm text-gray-300">Simulation de R√©seau Neuronal</p>
        </div>

        <nav class="flex-grow w-full">
            <ul>
                <li class="mb-2">
                    <a href="#overview" class="nav-item flex items-center p-3 rounded-lg text-lg active">
                        <span class="mr-3">üìä</span> Vue d'ensemble
                    </a>
                </li>
                <li class="mb-2">
                    <a href="#stats" class="nav-item flex items-center p-3 rounded-lg text-lg">
                        <span class="mr-3">üìà</span> Statistiques
                    </a>
                </li>
                <li class="mb-2">
                    <a href="#config" class="nav-item flex items-center p-3 rounded-lg text-lg">
                        <span class="mr-3">‚öôÔ∏è</span> Configuration
                    </a>
                </li>
                <li class="mb-2">
                    <a href="#logs" class="nav-item flex items-center p-3 rounded-lg text-lg">
                        <span class="mr-3">üìú</span> Journal
                    </a>
                </li>
            </ul>
        </nav>

        <div class="w-full mt-auto pt-6 border-t border-gray-700 text-sm text-gray-400 text-center">
            &copy; 2025 NeuraX Systems
        </div>
    </aside>

    <main class="main-content-area flex-grow p-4 md:p-8 relative">
        <button id="menuToggle" class="md:hidden fixed top-4 left-4 z-50 p-3 bg-gray-800 text-white rounded-lg shadow-lg">
            ‚ò∞
        </button>

        <div class="container mx-auto">
            <h1 class="text-4xl font-extrabold text-gray-800 mb-8 text-center">Bienvenue sur NeuraX-Ultime</h1>

            <div class="bg-white p-6 rounded-lg shadow-md mb-8">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">Contr√¥le Syst√®me</h2>
                <div class="flex flex-col md:flex-row items-center justify-between space-y-4 md:space-y-0 md:space-x-4">
                    <button id="startBtn" class="btn-primary py-3 px-6 rounded-full text-lg font-semibold shadow-lg hover:shadow-xl transition duration-300 ease-in-out flex-grow">
                        D√©marrer le Syst√®me NeuraX
                    </button>
                    <button id="deactivateBtn" class="btn-secondary py-3 px-6 rounded-full text-lg font-semibold shadow-md hover:shadow-lg transition duration-300 ease-in-out flex-grow hidden">
                        D√©sactiver le Syst√®me
                    </button>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <div class="bg-white p-6 rounded-lg shadow-md flex flex-col">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4">Visualisation du R√©seau</h2>
                    <div class="canvas-container flex-grow">
                        <canvas id="neuralCanvas"></canvas>
                    </div>
                    <div class="mt-4 text-sm text-gray-600 text-center">
                        <p>Le r√©seau s'adapte et √©volue en temps r√©el.</p>
                        <p>Nb. Neurones: <span id="neuronCount" class="font-semibold text-primary">0</span> |
                           Nb. Synapses: <span id="synapseCount" class="font-semibold text-primary">0</span></p>
                        <div class="w-full bg-gray-200 rounded-full h-2.5 mt-2">
                            <div id="replicationProgress" class="progress-bar-fill h-2.5 rounded-full" style="width: 0%"></div>
                        </div>
                        <p class="text-xs text-gray-500 mt-1">Progression de la R√©plication</p>
                    </div>
                </div>

                <div class="bg-white p-6 rounded-lg shadow-md flex flex-col">
                    <h2 class="text-2xl font-bold text-gray-800 mb-4">Interface de Communication (IA)</h2>
                    <div id="chatBody" class="flex-grow bg-gray-50 p-4 rounded-lg overflow-y-auto mb-4 custom-scrollbar" style="max-height: 400px; min-height: 200px;">
                        <div class="chat-message ai p-3 rounded-lg mb-2 max-w-xs md:max-w-md shadow-sm">Bonjour ! Je suis NeuraX. Comment puis-je vous aider aujourd'hui ?</div>
                    </div>
                    <div class="flex items-center space-x-3">
                        <input type="text" id="chatInput" placeholder="Posez une question √† NeuraX..." class="flex-grow p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary">
                        <button id="sendBtn" class="btn-primary p-3 rounded-lg shadow-md hover:shadow-lg transition duration-300 ease-in-out">
                            <span class="mr-2">üöÄ</span> Envoyer
                        </button>
                        <button id="voiceBtn" class="p-3 bg-gray-200 rounded-lg shadow-md hover:shadow-lg transition duration-300 ease-in-out">
                            <span class="text-lg">üéôÔ∏è</span>
                            <span class="voice-active-dot hidden"></span>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <div id="activationModal" class="modal fixed inset-0 flex items-center justify-center hidden">
        <div class="bg-white p-8 rounded-lg shadow-2xl max-w-sm w-full text-center">
            <h3 class="text-xl font-bold mb-4">Activation du Syst√®me NeuraX</h3>
            <p class="mb-4">Choisissez un niveau d'initialisation pour le r√©seau (influence le taux de croissance).</p>
            <input type="range" id="activationLevel" min="1" max="100" value="50" class="w-full accent-primary">
            <p class="text-sm text-gray-600 mt-1">Niveau: <span id="currentActivationLevel">50</span>%</p>

            <div class="flex justify-end space-x-4 mt-6">
                <button id="cancelActivation" class="btn-secondary py-2 px-4 rounded-lg">Annuler</button>
                <button id="confirmActivation" class="btn-primary py-2 px-4 rounded-lg">Confirmer</button>
            </div>
        </div>
    </div>

    <div id="toastContainer" class="toast-container space-y-3"></div>

    <script>
        // Configuration avanc√©e du r√©seau neural
        const neuralConfig = {
            neurons: {
                count: 0,
                maxCount: 300,
                baseSize: 2,
                activeSize: 4,
                colors: ['#3498db', '#9b59b6', '#2ecc71', '#e74c3c', '#f39c12'],
                speed: 0.3,
                connectionDistance: 180,
                connectionOpacity: 0.25,
                growthRate: 15,
                decayRate: 0.05,
                lifespanFactor: 1000,
                mutationRate: 0.02
            },
            animation: {
                pulseFrequency: 2000,
                waveEffect: true,
                glowIntensity: 0.7
            },
            learning: {
                enabled: true,
                adaptiveThreshold: 0.4,
                memoryCapacity: 50,
                patternRecognition: 0.6
            }
        };
        // Classe Neurone am√©lior√©e
        class Neuron {
            constructor(x, y, size, color) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.color = color;
                this.originalColor = color;
                this.speedX = (Math.random() - 0.5) * neuralConfig.neurons.speed;
                this.speedY = (Math.random() - 0.5) * neuralConfig.neurons.speed;
                this.active = false;
                this.energy = 100;
                this.age = 0;
                this.lifespan = Math.random() * neuralConfig.neurons.lifespanFactor + 5000;
                this.connections = [];
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.lastActivation = 0;
                this.activationHistory = [];
                this.specializationType = Math.floor(Math.random() * 4); // 0: sensory, 1: motor, 2: association, 3: inhibitory
            }
            update(deltaTime, canvas) {
                // Mise √† jour de la position
                this.x += this.speedX;
                this.y += this.speedY;
                // Rebond sur les bords
                if (this.x < 0 || this.x > canvas.width) this.speedX *= -1;
                if (this.y < 0 || this.y > canvas.height) this.speedY *= -1;
                // Vieillissement et √©nergie
                this.age += deltaTime;
                if (this.active) {
                    this.energy -= deltaTime * 0.02;
                } else {
                    this.energy = Math.min(100, this.energy + deltaTime * 0.005);
                }
                // Effet de pulsation
                const pulseSize = Math.sin(this.pulsePhase + performance.now() / neuralConfig.animation.pulseFrequency) * 0.5 + 1;
                this.displaySize = this.active ? this.size * neuralConfig.neurons.activeSize * pulseSize : this.size * pulseSize;
                // Mise √† jour de la couleur bas√©e sur l'√©nergie
                const energyFactor = this.energy / 100;
                const r = parseInt(this.originalColor.slice(1, 3), 16);
                const g = parseInt(this.originalColor.slice(3, 5), 16);
                const b = parseInt(this.originalColor.slice(5, 7), 16);
                this.displayColor = this.active
                    ? `rgba(${r}, ${g}, ${b}, ${energyFactor})`
                    : `rgba(${r}, ${g}, ${b}, ${energyFactor * 0.6})`;
                // Mutation occasionnelle
                if (Math.random() < neuralConfig.neurons.mutationRate * deltaTime / 1000) {
                    this.mutate();
                }
                return this.age < this.lifespan && this.energy > 0;
            }
            activate(duration = 2000) {
                this.active = true;
                this.lastActivation = performance.now();
                this.activationHistory.push(performance.now());
                // Garder seulement les 20 derni√®res activations pour la m√©moire
                if (this.activationHistory.length > 20) {
                    this.activationHistory.shift();
                }
                // D√©sactiver apr√®s une dur√©e
                setTimeout(() => {
                    this.active = false;
                }, duration);
                return this;
            }
            connect(targetNeuron, strength = Math.random()) {
                const connection = {
                    target: targetNeuron,
                    strength: strength,
                    age: 0,
                    active: false,
                    source: this // Add source to connection for easier lookup
                };
                this.connections.push(connection);
                return connection;
            }
            mutate() {
                // Mutation l√©g√®re des propri√©t√©s
                this.speedX += (Math.random() - 0.5) * 0.02;
                this.speedY += (Math.random() - 0.5) * 0.02;
                this.lifespan *= 0.95 + Math.random() * 0.1;
                // Mutation de couleur occasionnelle
                if (Math.random() < 0.2) {
                    const colors = neuralConfig.neurons.colors;
                    this.originalColor = colors[Math.floor(Math.random() * colors.length)];
                }
            }
            draw(ctx) {
                // Dessiner le neurone avec effet de lueur
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.displaySize, 0, Math.PI * 2);
                // Ajouter un effet de lueur si actif
                if (this.active && neuralConfig.animation.glowIntensity > 0) {
                    ctx.shadowBlur = 15 * neuralConfig.animation.glowIntensity;
                    ctx.shadowColor = this.originalColor;
                } else {
                    ctx.shadowBlur = 0;
                }
                ctx.fillStyle = this.displayColor;
                ctx.fill();
                // Marqueur de sp√©cialisation (petit symbole selon le type)
                if (this.active) {
                    ctx.beginPath();
                    const markerSize = this.displaySize * 0.5;
                    ctx.strokeStyle = "#ffffff";
                    ctx.lineWidth = 1;
                    switch(this.specializationType) {
                        case 0: // Sensoriel - cercle
                            ctx.arc(this.x, this.y, markerSize * 0.3, 0, Math.PI * 2);
                            break;
                        case 1: // Moteur - triangle
                            ctx.moveTo(this.x, this.y - markerSize * 0.3);
                            ctx.lineTo(this.x + markerSize * 0.3, this.y + markerSize * 0.3);
                            ctx.lineTo(this.x - markerSize * 0.3, this.y + markerSize * 0.3);
                            break;
                        case 2: // Association - carr√©
                            ctx.rect(this.x - markerSize * 0.2, this.y - markerSize * 0.2, markerSize * 0.4, markerSize * 0.4);
                            break;
                        case 3: // Inhibiteur - croix
                            ctx.moveTo(this.x - markerSize * 0.2, this.y - markerSize * 0.2);
                            ctx.lineTo(this.x + markerSize * 0.2, this.y + markerSize * 0.2);
                            ctx.moveTo(this.x + markerSize * 0.2, this.y - markerSize * 0.2);
                            ctx.lineTo(this.x - markerSize * 0.2, this.y + markerSize * 0.2);
                            break;
                    }
                    ctx.stroke();
                }
            }
        }
        // Classe pour le r√©seau neuronal
        class NeuralNetwork {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.neurons = [];
                this.connections = [];
                this.isActive = false;
                this.lastUpdate = performance.now();
                this.stats = {
                    neuronCount: 0,
                    connectionCount: 0,
                    activeNeurons: 0,
                    averageEnergy: 0,
                    cycles: 0,
                    patternMatches: 0
                };
                this.memoryPatterns = [];
                this.eventListeners = {};
                // Bind canvas resize
                window.addEventListener('resize', this.resizeCanvas.bind(this));
                this.resizeCanvas();
            }
            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
            }
            initialize(initialNeurons = 50) {
                this.resizeCanvas(); // Ensure canvas is sized correctly on init
                // Cr√©er les premiers neurones
                for (let i = 0; i < initialNeurons; i++) {
                    this.createNeuron();
                }
                // D√©marrer la boucle d'animation
                this.lastUpdate = performance.now();
                this.animate();
                return this;
            }
            createNeuron(x, y) {
                // Position al√©atoire si non sp√©cifi√©e
                x = x || Math.random() * this.canvas.width;
                y = y || Math.random() * this.canvas.height;
                const size = neuralConfig.neurons.baseSize;
                const colorIndex = Math.floor(Math.random() * neuralConfig.neurons.colors.length);
                const color = neuralConfig.neurons.colors[colorIndex];
                const neuron = new Neuron(x, y, size, color);
                this.neurons.push(neuron);
                // Cr√©er des connexions avec les neurones existants
                const nearbyNeurons = this.findNearbyNeurons(neuron, neuralConfig.neurons.connectionDistance);
                for (const targetNeuron of nearbyNeurons) {
                    if (Math.random() < 0.3) { // 30% de chance de connexion
                        const connection = neuron.connect(targetNeuron);
                        this.connections.push(connection);
                    }
                }
                this.stats.neuronCount = this.neurons.length;
                this.trigger('neuronCreated', neuron);
                return neuron;
            }
            findNearbyNeurons(neuron, maxDistance) {
                return this.neurons.filter(n => {
                    if (n === neuron) return false;
                    const dx = n.x - neuron.x;
                    const dy = n.y - neuron.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance < maxDistance;
                });
            }
            animate() {
                // Calculer le temps √©coul√© depuis la derni√®re mise √† jour
                const now = performance.now();
                const deltaTime = now - this.lastUpdate;
                this.lastUpdate = now;
                // Effacer le canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                // Mettre √† jour les neurones et les connexions
                this.updateNetwork(deltaTime);
                // Croissance automatique si actif
                if (this.isActive && this.neurons.length < neuralConfig.neurons.maxCount) {
                    if (Math.random() < neuralConfig.neurons.growthRate * deltaTime / 5000) {
                        this.createNeuron();
                    }
                }
                // Reconna√Ætre des motifs
                this.recognizePatterns();
                // Mettre √† jour les statistiques
                this.updateStats();
                // Continuer l'animation
                requestAnimationFrame(() => this.animate());
            }
            updateNetwork(deltaTime) {
                // Mettre √† jour et dessiner les connexions
                this.drawConnections();
                // Mettre √† jour et dessiner les neurones, supprimer les morts
                let activeCount = 0;
                let totalEnergy = 0;
                const deadNeurons = [];
                for (let i = 0; i < this.neurons.length; i++) {
                    const neuron = this.neurons[i];
                    const isAlive = neuron.update(deltaTime, this.canvas); // Pass canvas for bounds check
                    if (!isAlive) {
                        deadNeurons.push(i);
                    } else {
                        neuron.draw(this.ctx);
                        // Compter les neurones actifs et l'√©nergie totale
                        if (neuron.active) activeCount++;
                        totalEnergy += neuron.energy;
                        // Propagation d'activation entre neurones connect√©s
                        if (neuron.active && Math.random() < 0.1) {
                            this.propagateActivation(neuron);
                        }
                    }
                }
                // Supprimer les neurones morts (en partant de la fin pour ne pas perturber les indices)
                for (let i = deadNeurons.length - 1; i >= 0; i--) {
                    this.neurons.splice(deadNeurons[i], 1);
                }
                if (deadNeurons.length > 0) {
                    this.trigger('neuronsRemoved', deadNeurons.length);
                }
                // Mettre √† jour les statistiques
                this.stats.activeNeurons = activeCount;
                this.stats.averageEnergy = this.neurons.length > 0 ? totalEnergy / this.neurons.length : 0;
                this.stats.cycles++;
            }
            drawConnections() {
                // Mise √† jour des connexions et dessin
                const deadConnections = [];
                for (let i = 0; i < this.connections.length; i++) {
                    const connection = this.connections[i];
                    // V√©rifier si les neurones existent toujours
                    const source = connection.source;
                    const target = connection.target;
                    // Check if both source and target neurons still exist in the network's neurons array
                    if (!this.neurons.includes(source) || !this.neurons.includes(target)) {
                        deadConnections.push(i);
                        continue;
                    }
                    // Calculer la distance
                    const dx = target.x - source.x;
                    const dy = target.y - source.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    // Dessiner seulement si assez proche
                    if (distance < neuralConfig.neurons.connectionDistance) {
                        // Calculer l'opacit√© bas√©e sur la distance et l'√©nergie
                        const distanceFactor = 1 - distance / neuralConfig.neurons.connectionDistance;
                        const energyFactor = (source.energy + target.energy) / 200;
                        const opacity = distanceFactor * neuralConfig.neurons.connectionOpacity * energyFactor;
                        // D√©terminer la couleur
                        let color;
                        if (source.active && target.active) {
                            // Connexion tr√®s active
                            color = `rgba(255, 255, 255, ${opacity * 1.5})`;
                        } else if (source.active || target.active) {
                            // Connexion semi-active
                            const r = parseInt(source.originalColor.slice(1, 3), 16);
                            const g = parseInt(source.originalColor.slice(3, 5), 16);
                            const b = parseInt(source.originalColor.slice(5, 7), 16);
                            color = `rgba(${r}, ${g}, ${b}, ${opacity * 1.2})`;
                        } else {
                            // Connexion inactive
                            color = `rgba(52, 152, 219, ${opacity})`;
                        }
                        // Dessiner la connexion
                        this.ctx.beginPath();
                        this.ctx.moveTo(source.x, source.y);
                        this.ctx.lineTo(target.x, target.y);
                        this.ctx.strokeStyle = color;
                        this.ctx.lineWidth = source.active || target.active ? 1.5 : 1;
                        // Effet de pulsation sur les connexions actives
                        if ((source.active || target.active) && neuralConfig.animation.waveEffect) {
                            this.ctx.setLineDash([5, 5]);
                            this.ctx.lineDashOffset = -performance.now() / 100;
                        } else {
                            this.ctx.setLineDash([]);
                        }
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);
                    } else {
                        // Connexion trop √©loign√©e
                        deadConnections.push(i);
                    }
                }
                // Supprimer les connexions mortes
                for (let i = deadConnections.length - 1; i >= 0; i--) {
                    this.connections.splice(deadConnections[i], 1);
                }
                this.stats.connectionCount = this.connections.length;
            }
            propagateActivation(sourceNeuron) {
                // Propager l'activation aux neurones connect√©s
                for (const connection of sourceNeuron.connections) {
                    const targetNeuron = connection.target;
                    // Probabilit√© d'activation bas√©e sur la force de la connexion
                    if (Math.random() < connection.strength * 0.7 && !targetNeuron.active) { // Prevent reactivating already active neurons
                        targetNeuron.activate(1000 + Math.random() * 1000);
                        // Renforcer la connexion (apprentissage)
                        if (neuralConfig.learning.enabled) {
                            connection.strength = Math.min(1, connection.strength + 0.01);
                        }
                    }
                }
            }
            activateRandomNeurons(count = 3) {
                // Activer quelques neurones al√©atoires pour stimuler le r√©seau
                if (this.neurons.length === 0) return;
                for (let i = 0; i < count; i++) {
                    const index = Math.floor(Math.random() * this.neurons.length);
                    if (this.neurons[index]) {
                        this.neurons[index].activate(2000 + Math.random() * 3000);
                    }
                }
            }
            activateByPattern(pattern) {
                // Activation bas√©e sur un motif sp√©cifique (ex: entr√©e utilisateur)
                if (this.neurons.length === 0) return;
                // Convertir le pattern en une empreinte d'activation
                const patternHash = this.hashPattern(pattern);
                // S√©lectionner les neurones √† activer bas√©s sur le hash
                const neuronIndices = [];
                // Simple mapping: use character codes to pick neurons
                for (let i = 0; i < pattern.length; i++) {
                    const charCode = pattern.charCodeAt(i);
                    const index = charCode % this.neurons.length; // Ensures index is within bounds
                    if (!neuronIndices.includes(index)) { // Avoid duplicate activations for same pattern char
                         neuronIndices.push(index);
                    }
                }
                // Activer les neurones s√©lectionn√©s
                for (const index of neuronIndices) {
                    if (this.neurons[index]) { // Ensure neuron still exists
                        this.neurons[index].activate(3000);
                    }
                }
                // M√©moriser le motif
                if (neuralConfig.learning.enabled) {
                    const currentPattern = {
                        pattern: patternHash,
                        originalPattern: pattern, // Store original for potential debug/recall
                        neurons: [...new Set(neuronIndices)], // Store unique indices
                        timestamp: Date.now()
                    };
                    // Check if a similar pattern already exists to avoid exact duplicates
                    const existing = this.memoryPatterns.find(mp => mp.pattern === currentPattern.pattern);
                    if (!existing) {
                        this.memoryPatterns.push(currentPattern);
                        // Limiter la taille de la m√©moire
                        if (this.memoryPatterns.length > neuralConfig.learning.memoryCapacity) {
                            this.memoryPatterns.shift();
                        }
                        this.trigger('patternMemorized', currentPattern);
                    }
                }
                this.trigger('patternActivated', pattern);
            }
            recognizePatterns() {
                // Analyser l'√©tat actuel pour reconna√Ætre des motifs connus
                if (!neuralConfig.learning.enabled || this.neurons.length === 0) return;
                // Cr√©er une empreinte de l'√©tat actuel des neurones
                const activeNeuronIndices = [];
                for (let i = 0; i < this.neurons.length; i++) {
                    if (this.neurons[i].active) {
                        activeNeuronIndices.push(i);
                    }
                }
                if (activeNeuronIndices.length < 3) return; // Pas assez de neurones actifs pour une reconnaissance significative
                // Comparer avec les motifs m√©moris√©s
                for (const pattern of this.memoryPatterns) {
                    let matches = 0;
                    for (const activeIndex of activeNeuronIndices) {
                        if (pattern.neurons.includes(activeIndex)) {
                            matches++;
                        }
                    }
                    // Calculer le score de correspondance
                    const matchScore = matches / Math.max(pattern.neurons.length, activeNeuronIndices.length);
                    // Si assez similaire, c'est un match
                    if (matchScore > neuralConfig.learning.patternRecognition) {
                        this.stats.patternMatches++;
                        this.trigger('patternRecognized', pattern);
                        // Renforcer ce motif en activant les neurones associ√©s
                        for (const neuronIndex of pattern.neurons) {
                            if (this.neurons[neuronIndex]) { // Ensure neuron still exists
                                this.neurons[neuronIndex].activate(2000);
                            }
                        }
                        return pattern; // Return the recognized pattern
                    }
                }
                return null; // No pattern recognized
            }
            hashPattern(input) {
                // Fonction simple pour cr√©er un hash du motif
                let hash = 0;
                for (let i = 0; i < input.length; i++) {
                    const char = input.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Conversion en entier 32 bits
                }
                return hash.toString(); // Return as string to avoid numerical issues with large hashes
            }
            updateStats() {
                // Mettre √† jour les statistiques de r√©seau
                document.getElementById('neuronCount').textContent = this.stats.neuronCount;
                document.getElementById('synapseCount').textContent = this.stats.connectionCount;
                // Mettre √† jour la progression de r√©plication
                const progress = Math.min(100, Math.floor((this.stats.neuronCount / neuralConfig.neurons.maxCount) * 100));
                document.getElementById('replicationProgress').style.width = `${progress}%`;
            }
            activate() {
                // Activer le syst√®me neural
                this.isActive = true;
                this.activateRandomNeurons(5);
                // D√©marrer l'activation cyclique
                this.activationInterval = setInterval(() => {
                    this.activateRandomNeurons(2);
                }, 2000);
                this.trigger('systemActivated');
                return this;
            }
            deactivate() {
                // D√©sactiver le syst√®me neural
                this.isActive = false;
                clearInterval(this.activationInterval);
                this.trigger('systemDeactivated');
                return this;
            }
            // Syst√®me d'√©v√©nements simple
            on(eventName, callback) {
                if (!this.eventListeners[eventName]) {
                    this.eventListeners[eventName] = [];
                }
                this.eventListeners[eventName].push(callback);
                return this;
            }
            trigger(eventName, data) {
                if (this.eventListeners[eventName]) {
                    for (const callback of this.eventListeners[eventName]) {
                        callback(data);
                    }
                }
                return this;
            }
            // Fonctions d'analyse
            generateReport() {
                return {
                    neuronCount: this.stats.neuronCount,
                    connectionCount: this.stats.connectionCount,
                    activeNeurons: this.stats.activeNeurons,
                    averageEnergy: this.stats.averageEnergy.toFixed(2),
                    networkDensity: this.stats.neuronCount > 1 ? (this.stats.connectionCount / (this.stats.neuronCount * (this.stats.neuronCount - 1) / 2)).toFixed(4) : 0,
                    recognizedPatterns: this.stats.patternMatches,
                    memorySize: this.memoryPatterns.length,
                    systemStatus: this.isActive ? 'Actif' : 'Inactif',
                    timestamp: new Date().toISOString()
                };
            }
            // Sauvegarde et chargement
            exportState() {
                // Version simplifi√©e - sauvegarde uniquement les configurations et statistiques
                return {
                    config: neuralConfig,
                    stats: this.stats,
                    memoryPatterns: this.memoryPatterns.map(p => ({
                        pattern: p.pattern,
                        neurons: p.neurons,
                        timestamp: p.timestamp,
                        originalPattern: p.originalPattern // Also store original for display
                    })),
                    timestamp: Date.now()
                };
            }
            importState(state) {
                // Importer seulement ce qui est s√ªr
                if (state.config) {
                    // Mise √† jour de la configuration en pr√©servant la structure
                    Object.keys(state.config).forEach(section => {
                        if (neuralConfig[section]) {
                            Object.keys(state.config[section]).forEach(param => {
                                if (neuralConfig[section][param] !== undefined) {
                                    neuralConfig[section][param] = state.config[section][param];
                                }
                            });
                        }
                    });
                }
                if (state.memoryPatterns) {
                    // Filtrer uniquement les motifs valides
                    this.memoryPatterns = state.memoryPatterns.filter(p =>
                        p.pattern && Array.isArray(p.neurons) && p.timestamp
                    ).slice(0, neuralConfig.learning.memoryCapacity);
                }
                // Note: Re-creating neurons from state requires more complex serialization,
                // so for this example, we only import config and patterns.
                return this;
            }
        }
        // Fonctions utilitaires pour l'interface utilisateur
        const NeuraXUI = {
            neuralNetwork: null,
            voiceRecognitionActive: false,
            // Initialisation de l'interface
            initialize(neuralNetworkInstance) {
                this.neuralNetwork = neuralNetworkInstance;

                // Configure event listeners
                document.getElementById('startBtn').addEventListener('click', () => {
                    document.getElementById('activationModal').style.display = 'flex';
                    document.getElementById('currentActivationLevel').textContent = document.getElementById('activationLevel').value;
                });
                document.getElementById('deactivateBtn').addEventListener('click', () => {
                    this.deactivateSystem();
                });
                document.getElementById('closeActivationModal').addEventListener('click', () => {
                    document.getElementById('activationModal').style.display = 'none';
                });
                document.getElementById('cancelActivation').addEventListener('click', () => {
                    document.getElementById('activationModal').style.display = 'none';
                });
                document.getElementById('confirmActivation').addEventListener('click', () => {
                    document.getElementById('activationModal').style.display = 'none';
                    this.activateSystem();
                });
                document.getElementById('activationLevel').addEventListener('input', (e) => {
                    document.getElementById('currentActivationLevel').textContent = e.target.value;
                });

                // Chat
                const chatInput = document.getElementById('chatInput');
                const sendBtn = document.getElementById('sendBtn');
                chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.sendChatMessage();
                    }
                });
                sendBtn.addEventListener('click', () => {
                    this.sendChatMessage();
                });
                document.getElementById('voiceBtn').addEventListener('click', (e) => {
                    this.toggleVoiceRecognition(e.currentTarget);
                });

                // Menu lat√©ral
                document.getElementById('menuToggle')?.addEventListener('click', () => {
                    document.getElementById('sidebar').classList.toggle('open');
                });
                // Fermer le menu lat√©ral si clic √† l'ext√©rieur (pour mobile)
                document.addEventListener('click', (event) => {
                    const sidebar = document.getElementById('sidebar');
                    const menuToggle = document.getElementById('menuToggle');
                    if (sidebar.classList.contains('open') && !sidebar.contains(event.target) && !menuToggle.contains(event.target)) {
                        sidebar.classList.remove('open');
                    }
                });


                // Navigation
                const navItems = document.querySelectorAll('.nav-item');
                navItems.forEach(item => {
                    item.addEventListener('click', (e) => {
                        // Emp√™cher la navigation par d√©faut
                        if (item.getAttribute('href') && item.getAttribute('href').startsWith('#')) {
                            e.preventDefault();
                        }
                        // Retirer la classe active de tous les √©l√©ments
                        navItems.forEach(navItem => navItem.classList.remove('active'));
                        // Ajouter la classe active √† l'√©l√©ment cliqu√©
                        item.classList.add('active');
                        // Simuler le changement de section
                        const sectionName = item.querySelector('span:last-child').textContent.trim();
                        this.showToast(`Navigation vers ${sectionName}`, 'success');

                        // For a real SPA, you'd hide/show content based on sectionName
                        // For this demo, just toast.
                    });
                });

                // Initial messages
                this.addChatMessage('Bonjour ! Je suis NeuraX. Comment puis-je vous aider aujourd\'hui ?', 'ai');

                // Listen for network events
                this.neuralNetwork.on('systemActivated', () => {
                    document.getElementById('startBtn').classList.add('hidden');
                    document.getElementById('deactivateBtn').classList.remove('hidden');
                    this.addChatMessage('Syst√®me NeuraX activ√©. Initialisation du r√©seau en cours...', 'ai');
                });
                this.neuralNetwork.on('systemDeactivated', () => {
                    document.getElementById('deactivateBtn').classList.add('hidden');
                    document.getElementById('startBtn').classList.remove('hidden');
                    this.addChatMessage('Syst√®me NeuraX d√©sactiv√©. Mise en veille des processus.', 'ai');
                });
                this.neuralNetwork.on('patternRecognized', (patternData) => {
                    this.addChatMessage(`NeuraX a reconnu un motif ! (${patternData.originalPattern || patternData.pattern})`, 'ai');
                });
                this.neuralNetwork.on('patternMemorized', (patternData) => {
                    this.addChatMessage(`NeuraX a m√©moris√© un nouveau motif.`, 'ai');
                });
            },
            // Activation du syst√®me
            activateSystem() {
                const activationLevel = parseInt(document.getElementById('activationLevel').value, 10);
                if (this.neuralNetwork) {
                    this.neuralNetwork.activate();
                    neuralConfig.neurons.growthRate = 5 + (activationLevel / 10); // Adjust growth based on level
                    this.showToast(`NeuraX-Ultime activ√© avec un niveau d'initialisation de ${activationLevel}%`, 'success');
                } else {
                    this.showToast('Erreur: R√©seau neural non initialis√©', 'error');
                }
            },
            // D√©sactivation du syst√®me
            deactivateSystem() {
                if (this.neuralNetwork) {
                    this.neuralNetwork.deactivate();
                    this.showToast('NeuraX-Ultime d√©sactiv√©.', 'info');
                }
            },
            // Gestion du chat
            sendChatMessage() {
                const chatInput = document.getElementById('chatInput');
                const message = chatInput.value.trim();
                if (!message) return;

                this.addChatMessage(message, 'user');
                chatInput.value = '';

                // Activer le mod√®le neural avec ce pattern
                if (this.neuralNetwork) {
                    this.neuralNetwork.activateByPattern(message);
                }

                // Afficher l'indicateur de r√©flexion
                const chatBody = document.getElementById('chatBody');
                const thinkingIndicator = document.createElement('div');
                thinkingIndicator.className = 'thinking-indicator';
                thinkingIndicator.innerHTML = `
                    <div class="thinking-dot"></div>
                    <div class="thinking-dot"></div>
                    <div class="thinking-dot"></div>
                `;
                chatBody.appendChild(thinkingIndicator);
                chatBody.scrollTop = chatBody.scrollHeight;

                // Traiter la r√©ponse (avec un d√©lai pour simuler l'IA)
                setTimeout(() => {
                    thinkingIndicator.remove();
                    this.generateResponse(message);
                }, 1500 + Math.random() * 1000); // Simulate varying response times
            },
            addChatMessage(text, type) {
                const chatBody = document.getElementById('chatBody');
                const messageEl = document.createElement('div');
                messageEl.className = `chat-message p-3 rounded-lg mb-2 max-w-xs md:max-w-md shadow-sm ${type}`;
                messageEl.textContent = text;
                chatBody.appendChild(messageEl);
                chatBody.scrollTop = chatBody.scrollHeight; // Scroll to bottom
            },
            // Impl√©mentation de generateResponse
            generateResponse(userMessage) {
                const report = this.neuralNetwork.generateReport();
                let response = "";

                const lowerCaseMessage = userMessage.toLowerCase();

                if (lowerCaseMessage.includes("bonjour") || lowerCaseMessage.includes("salut")) {
                    response = "Bonjour ! Comment puis-je vous assister concernant le r√©seau NeuraX ?";
                } else if (lowerCaseMessage.includes("comment vas-tu") || lowerCaseMessage.includes("ca va")) {
                    response = "En tant que syst√®me num√©rique, je n'ai pas de sensations, mais tous mes modules fonctionnent de mani√®re optimale. Merci de demander !";
                } else if (lowerCaseMessage.includes("combien de neurones")) {
                    response = `Actuellement, le r√©seau compte ${report.neuronCount} neurones.`;
                } else if (lowerCaseMessage.includes("combien de synapses") || lowerCaseMessage.includes("connexions")) {
                    response = `Il y a ${report.connectionCount} synapses actives dans le r√©seau.`;
                } else if (lowerCaseMessage.includes("√©tat du syst√®me") || lowerCaseMessage.includes("actif") || lowerCaseMessage.includes("statut")) {
                    response = `Le syst√®me est actuellement ${report.systemStatus}. Il y a ${report.activeNeurons} neurones actifs en ce moment.`;
                } else if (lowerCaseMessage.includes("capacit√© de m√©moire")) {
                     response = `La capacit√© de m√©moire actuelle pour les motifs est de ${neuralConfig.learning.memoryCapacity} emplacements, et nous avons m√©moris√© ${report.memorySize} motifs.`;
                } else if (lowerCaseMessage.includes("que peux-tu faire")) {
                    response = "Je simule un r√©seau neuronal avec des capacit√©s de croissance, d'activation, de propagation et d'apprentissage de motifs. Je peux aussi vous fournir des statistiques en temps r√©el.";
                } else if (lowerCaseMessage.includes("merci") || lowerCaseMessage.includes("super")) {
                    response = "De rien ! N'h√©sitez pas si vous avez d'autres questions.";
                } else {
                    // Simulate pattern recognition feedback based on whether a pattern was activated/recognized
                    const recognizedPattern = this.neuralNetwork.recognizePatterns(); // Try to recognize current pattern after user input activation
                    if (recognizedPattern) {
                        response = `Je d√©tecte un motif li√© √† "${recognizedPattern.originalPattern || 'un concept abstrait'}". Int√©ressant.`;
                    } else if (report.activeNeurons > 0) {
                         response = `Je traite votre requ√™te... L'activit√© neurale est de ${report.activeNeurons} neurones actifs.`;
                    } else {
                        response = "Hmm, je n'ai pas de r√©ponse sp√©cifique pour cela pour le moment. Mon r√©seau est en cours d'analyse.";
                    }
                }
                this.addChatMessage(response, 'ai');
            },
            toggleVoiceRecognition(buttonElement) {
                const dot = buttonElement.querySelector('.voice-active-dot');
                if (!('webkitSpeechRecognition' in window)) {
                    this.showToast('La reconnaissance vocale n\'est pas support√©e par votre navigateur.', 'error');
                    return;
                }

                if (this.voiceRecognitionActive) {
                    // Stop recognition (simulated)
                    this.voiceRecognitionActive = false;
                    dot.classList.add('hidden');
                    this.showToast('Reconnaissance vocale d√©sactiv√©e.', 'info');
                } else {
                    // Start recognition (simulated)
                    this.voiceRecognitionActive = true;
                    dot.classList.remove('hidden');
                    this.showToast('Reconnaissance vocale activ√©e. Parlez maintenant...', 'success');

                    // Simulate actual voice recognition starting
                    const recognition = new webkitSpeechRecognition();
                    recognition.lang = 'fr-FR';
                    recognition.interimResults = false;
                    recognition.maxAlternatives = 1;

                    recognition.onresult = (event) => {
                        const transcript = event.results[0][0].transcript;
                        document.getElementById('chatInput').value = transcript;
                        this.sendChatMessage();
                        this.toggleVoiceRecognition(buttonElement); // Auto-stop after result
                    };

                    recognition.onerror = (event) => {
                        this.showToast(`Erreur de reconnaissance vocale: ${event.error}`, 'error');
                        this.toggleVoiceRecognition(buttonElement);
                    };

                    recognition.onend = () => {
                        if (this.voiceRecognitionActive) { // Only if not manually stopped
                            this.toggleVoiceRecognition(buttonElement);
                        }
                    };
                    recognition.start();
                }
            },
            showToast(message, type = 'info', duration = 3000) {
                const toastContainer = document.getElementById('toastContainer');
                const toast = document.createElement('div');
                toast.className = `toast p-3 rounded-lg shadow-md mb-3 flex items-center space-x-2 ${type}`;
                toast.innerHTML = `
                    <span class="text-xl">
                        ${type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : '‚ÑπÔ∏è'}
                    </span>
                    <span>${message}</span>
                `;
                toastContainer.appendChild(toast);

                setTimeout(() => {
                    toast.remove();
                }, duration);
            }
        };

        // Main execution when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('neuralCanvas');
            window.neuralNetwork = new NeuralNetwork(canvas); // Make it global for UI access
            window.neuralNetwork.initialize(50); // Start with 50 neurons

            NeuraXUI.initialize(window.neuralNetwork);

            // Update range slider value display
            document.getElementById('activationLevel').addEventListener('input', function() {
                document.getElementById('currentActivationLevel').textContent = this.value;
            });
        });
    </script>
</body>
</html>
